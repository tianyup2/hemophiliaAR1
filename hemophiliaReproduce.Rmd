---
title: "hemophiliaReproduce"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Summary
In the first section, we provide a sample code that can be run to show the sampling pipeline. In the second section, we present the code for summarizing the simulation results and reproduce the DGP1 ($K = 20, \rho = 0$) and DGP4 ($K = 20, \rho = 0.5$) with the obtained results. In the third section, we show how to submit tasks with slurm.


# Sample code

## Load the required packages
```{r}
rm(list=ls())
library(Rcpp)
library(spatstat)
library(rlang)
library(permute)

## output the package version
packageVersion("Rcpp")
packageVersion("spatstat")
packageVersion("rlang")
packageVersion("permute")
```  
The code was compiled using R/4.0.2 and the required packages were in the following versions,

Rcpp: 1.0.5
spatstat: 1.64.1
rlang: 1.1.1
permute: 0.9.5

```{r}
# the following Rcpp file includes necessary Bayesian sampling functions
sourceCpp("hemophiliaTruncAR1Final.cpp")
```  


## Reproduce DGP1

Consider the case when $K = 20, \rho = 0$, the simulation data can be generated using the following code,

### Data preparation
```{r}
# To reproduce the Table 1 result, one needs to set.seed from 1 to 100
set.seed(1)

# define external parameters
Ts1 <- 120
alpha1 <- matrix(60,nrow = 1,ncol = 1)
n1 <- 10
theta1 <- c(20,1,10,-0.1,8)

Tsw <- 120
alphaw <- matrix(60,nrow = 1,ncol = 1)
nw <- 10
thetaw <- c(20,1,10,-0.1,8)

# construct external trajectory lists
tList1 <- list()
nList1 <- list()
XList1 <- list()
YList1 <- list()

for(i in 1:n1){
  ni <- rpois(1,lambda = 20)
  tList1[[i]] <- matrix(sort(runif(ni,min = 0,max = Ts1)),ncol = 1)
  nList1[[i]] <- ni
}

XList1 <- getXList(tList1,alpha1[1,1],Ts1)
thetaMat1 <- matrix(0,nrow = n1 + nw,ncol = 5)
SigMat1 <- diag(c(abs(c(25,0.1,9,0.1,4))))

for(i in 1:n1){
  ni <- length(tList1[[i]])
  thetai <- tmvtnorm::rtmvnorm(1,mean = theta1,sigma = SigMat1)
  thetaMat1[i,] <- thetai
  epsMat <- arMat(rho = 0,tListi = tList1[[i]])
  eps <- mvtnorm::rmvnorm(1,mean = rep(0,ni),sigma = 4*epsMat)
  
  YList1[[i]] <- matrix(c(XList1[[i]]%*%matrix(thetai,ncol = 1)) + c(eps), ncol = 1) 
  
}

for(i in (n1+1):(n1 + nw)){
  ni <- rpois(1,lambda = 20)
  tList1[[i]] <- matrix(sort(runif(ni,min = 0,max = Tsw)),ncol = 1)
  nList1[[i]] <- ni
}

XList1 <- getXList(tList1,alphaw[1,1],Tsw)
SigMatw <- diag(c(abs(c(25,0.1,9,0.1,4))))

for(i in (n1+1):(n1 + nw)){
  ni <- length(tList1[[i]])
  thetai <- tmvtnorm::rtmvnorm(1,mean = thetaw,sigma = SigMatw)
  thetaMat1[i,] <- thetai
  
  epsMat <- arMat(rho = 0,tListi = tList1[[i]])
  eps <- mvtnorm::rmvnorm(1,mean = rep(0,ni),sigma = 4*epsMat)
  
  YList1[[i]] <- matrix(c(XList1[[i]]%*%matrix(thetai,ncol = 1)) + c(eps), ncol = 1) 
  
}

phaseExt <- matrix(0,nrow = sum(unlist(nList1)),ncol = 4)

n1count <- 0
for(i in 1:(n1 + nw)){
  ni <- nList1[[i]]
  phaseExt[(n1count + 1):(n1count + ni),1] <- rep(i,ni)
  phaseExt[(n1count + 1):(n1count + ni),2] <- tList1[[i]]
  phaseExt[(n1count + 1):(n1count + ni),3] <- YList1[[i]]
  phaseExt[(n1count + 1):(n1count + ni),4] <- rep("External",ni)
  n1count <- n1count + ni
}

phaseExt <- as.data.frame(phaseExt)
colnames(phaseExt) <- c("psuedo_id","TimeW","Value","Phase")
phaseExt$psuedo_id <- as.numeric(phaseExt$psuedo_id)
phaseExt$TimeW <- as.numeric(phaseExt$TimeW)
phaseExt$Value <- as.numeric(phaseExt$Value)
```  

```{r}
# define internal parameters
Ts2 <- 120
alpha2 <- matrix(60,nrow = 1,ncol = 1)
n2 <- 40
theta2 <- c(20,1,10,-0.1,8)

# construct internal trajectory lists
tList2 <- list()
nList2 <- list()
XList2 <- list()
YList2 <- list()

for(i in 1:n2){
  ni <- rpois(1,lambda = 20)
  # truncated before 40
  tList2[[i]] <- matrix(sort(runif(ni,min = 0,max = 60)),ncol = 1)
  nList2[[i]] <- ni
}

XList2 <- getXList(tList2,alpha2[1,1],Ts2)
thetaMat2 <- matrix(0,nrow = n2,ncol = 5)
SigMat2 <- diag(c(abs(c(25,0.1,9,0.1,4))))

for(i in 1:n2){
  ni <- length(tList2[[i]])
  thetai <- tmvtnorm::rtmvnorm(1,mean = theta2,sigma = SigMat2)
  thetaMat2[i,] <- thetai
  
  epsMat <- arMat(rho = 0,tListi = tList2[[i]])
  eps <- mvtnorm::rmvnorm(1,mean = rep(0,ni),sigma = 4*epsMat)
  
  YList2[[i]] <- matrix(c(XList2[[i]]%*%matrix(thetai,ncol = 1)) + c(eps), ncol = 1) 
  
}

phaseInt <- matrix(0,nrow = sum(unlist(nList2)),ncol = 4)

n2count <- 0
for(i in 1:n2){
  ni <- nList2[[i]]
  phaseInt[(n2count + 1):(n2count + ni),1] <- as.numeric(rep(i,ni))
  phaseInt[(n2count + 1):(n2count + ni),2] <- as.numeric(tList2[[i]])
  phaseInt[(n2count + 1):(n2count + ni),3] <- as.numeric(YList2[[i]])
  phaseInt[(n2count + 1):(n2count + ni),4] <- rep("Internal",ni)
  n2count <- n2count + ni
}

phaseInt <- as.data.frame(phaseInt)
colnames(phaseInt) <- c("psuedo_id","TimeW","Value","Phase")
phaseInt$psuedo_id <- as.numeric(phaseInt$psuedo_id)
phaseInt$TimeW <- as.numeric(phaseInt$TimeW)
phaseInt$Value <- as.numeric(phaseInt$Value)
```  

```{r}
# conduct z-transformation with starting value
# conduct z-transform
mVal <- mean(phaseInt$Value[which(phaseInt$TimeW <= 10)])
sdVal <- sd(phaseInt$Value[which(phaseInt$TimeW <= 10)])

phaseInt$Value <- (phaseInt$Value - mean(phaseInt$Value[which(phaseInt$TimeW <= 10)]))/
  sd(phaseInt$Value[which(phaseInt$TimeW <= 10)])
phaseExt$Value <- (phaseExt$Value - mean(phaseExt$Value[which(phaseExt$TimeW <= 10)]))/
  sd(phaseExt$Value[which(phaseExt$TimeW <= 10)])
```  

```{r}
# construct lists for the external and internal trajectories prior to
# a chosen time point. For simulation, this time point is chosen to be 60
tList1Sub <- list()
YList1Sub <- list()
tList2Sub <- list()
YList2Sub <- list()

TsThres <- 60
nExt <- 20
count <- 1
for(i in 1:nExt){
  tList1[[i]] <- matrix(phaseExt$TimeW[which(phaseExt$psuedo_id == i)],ncol = 1)
  YList1[[i]] <- matrix(phaseExt$Value[which(phaseExt$psuedo_id == i)],ncol = 1)
  
  idx <- which(tList1[[i]] <= TsThres)
  if(length(idx) > 0){
    tList1Sub[[count]] <- tList1[[i]][idx,,drop = FALSE]
    YList1Sub[[count]] <- YList1[[i]][idx,,drop = FALSE]
    count <- count + 1
  }
}

nInt <- 40
count <- 1
for(i in 1:nInt){
  tList2[[i]] <- matrix(phaseInt$TimeW[which(phaseInt$psuedo_id == i)],ncol = 1)
  YList2[[i]] <- matrix(phaseInt$Value[which(phaseInt$psuedo_id == i)],ncol = 1)
  
  idx <- which(tList2[[i]] <= TsThres)
  if(length(idx) > 0){
    tList2Sub[[count]] <- tList2[[i]][idx,,drop = FALSE]
    YList2Sub[[count]] <- YList2[[i]][idx,,drop = FALSE]
    count <- count + 1
  }
}
```  

### Model pretraining

To pretrain the model, we use the values given by the direct combination method as the initial value of the data selection method.

```{r}
# seed value can be fixed to 1
set.seed(1)
niter <- 2e3
nburn <- 1e3
niterOut <- 1e3
nSamp <- 1e3

Ts <- 120
beta0 <- matrix(0,nrow = 5,ncol = 1)
nu0 <-  1e-2
Psi0 <- diag(5) * 1e2
a0 <- 1e-2
b0 <- 1e-2

# train both subset
betaStarSub <- matrix(0,nrow = 5,ncol = 1)
SigmaStarSub <- diag(5)
sig201Sub <- matrix(1,nrow = 1,ncol = 1)
sig202Sub <- matrix(1,nrow = 1,ncol = 1)
alphaSub <- matrix(60,nrow = 1,ncol = 1)
rhoSub <- matrix(0.2,nrow = 1,ncol = 1)

alphaCollectSub <- list()
betaStarCollectSub <- list()
SigmaStarCollectSub <- list()
sig201CollectSub <- list()
sig202CollectSub <- list()
rhoCollectSub <- list()

# and complete data
betaStar <- matrix(0,nrow = 5,ncol = 1)
SigmaStar <- diag(5)

sig201 <- matrix(1,nrow = 1,ncol = 1)
sig202 <- matrix(1,nrow = 1,ncol = 1)

alpha <- matrix(60,nrow = 1,ncol = 1)
rho <- matrix(0.2,nrow = 1,ncol = 1)

alphaCollect <- list()
betaStarCollect <- list()
SigmaStarCollect <- list()
sig201Collect <- list()
sig202Collect <- list()
rhoCollect <- list()

SigRhoiList1 <- list()
SigRhoiList1Sub <- list()

for(i in 1:nExt){
  SigRhoiList1[[i]] <- arMat(rho = rho[1,1],tListi = tList1[[i]])
  SigRhoiList1Sub[[i]] <- arMat(rho = rhoSub[1,1],tListi = tList1Sub[[i]])
}

SigRhoiList2 <- list()
SigRhoiList2Sub <- list()

for(i in 1:nInt){
  SigRhoiList2[[i]] <- arMat(rho = rho[1,1],tListi = tList2[[i]])
  SigRhoiList2Sub[[i]] <- arMat(rho = rhoSub[1,1],tListi = tList2Sub[[i]])
}

####
# initialization
for(i in 1:niter){
  
  XList1 <- getXList(tList = tList1, alpha = alpha[1,1], Ts = Ts)
  
  XList2 <- getXList(tList = tList2, alpha = alpha[1,1], Ts = Ts)
  
  XList1Sub <- getXList(tList = tList1Sub, alpha = alphaSub[1,1], Ts = Ts)
  
  XList2Sub <- getXList(tList = tList2Sub, alpha = alphaSub[1,1], Ts = Ts)
  
  # update everything except for alpha
  getSampMixEffectHetero(YListS = YList1, XListS = XList1,
                         YListT = YList2, XListT = XList2,
                         beta0 = beta0, nu0 = nu0, Psi0 = Psi0,
                         a0 = a0, b0 = b0, 
                         SigRhoiListS = SigRhoiList1, SigRhoiListT = SigRhoiList2, 
                         betaStar = betaStar, SigmaStar = SigmaStar, 
                         sig20S = sig201, sig20T = sig202)
  
  getSampMixEffectHetero(YListS = YList1Sub,XListS = XList1Sub,
                         YListT = YList2Sub,XListT = XList2Sub,
                         beta0 = beta0, nu0 = nu0, Psi0 = Psi0,
                         a0 = a0, b0 = b0, 
                         SigRhoiListS = SigRhoiList1Sub, SigRhoiListT = SigRhoiList2Sub, 
                         betaStar = betaStarSub, SigmaStar = SigmaStarSub, 
                         sig20S = sig201Sub, sig20T = sig202Sub)
  
  # update Alpha
  getAlphaMixEffectHetero(YListS = YList1, XListS = XList1, tListS = tList1, 
                          YListT = YList2, XListT = XList2, tListT = tList2, 
                          Ts = Ts, alpha = alpha, 
                          SigRhoiListS = SigRhoiList1, SigRhoiListT = SigRhoiList2, 
                          betaStar = betaStar, SigmaStar = SigmaStar, 
                          sig20S = sig201, sig20T = sig202, deltaAlpha = Ts/60)
  
  getAlphaMixEffectHetero(YListS = YList1Sub, XListS = XList1Sub, tListS = tList1Sub, 
                          YListT = YList2Sub, XListT = XList2Sub, tListT = tList2Sub, 
                          Ts = Ts, alpha = alphaSub, 
                          SigRhoiListS = SigRhoiList1Sub, SigRhoiListT = SigRhoiList2Sub, 
                          betaStar = betaStarSub, SigmaStar = SigmaStarSub, 
                          sig20S = sig201Sub, sig20T = sig202Sub, deltaAlpha = Ts/60)
  
  # update rho
  SigRhoiList1 <- getRhoMixEffect(YList = YList1, tList = tList1, Ts = Ts, 
                                  rho = rho, SigRhoiList = SigRhoiList1, 
                                  alpha = alpha, betaStar = betaStar, SigmaStar = SigmaStar, 
                                  sig20 = sig201, deltaRho = 0.03)
  
  SigRhoiList2 <- getRhoMixEffect(YList = YList2, tList = tList2, Ts = Ts, 
                                  rho = rho, SigRhoiList = SigRhoiList2, 
                                  alpha = alpha, betaStar = betaStar, SigmaStar = SigmaStar, 
                                  sig20 = sig202, deltaRho = 0.03)
  # Sub
  SigRhoiList1Sub <- getRhoMixEffect(YList = YList1Sub, tList = tList1Sub, Ts = Ts,
                                     rho = rhoSub, SigRhoiList = SigRhoiList1Sub,
                                     alpha = alphaSub, betaStar = betaStarSub, SigmaStar = SigmaStarSub, 
                                     sig20 = sig201Sub, deltaRho = 0.03)
  
  SigRhoiList2Sub <- getRhoMixEffect(YList = YList2Sub, tList = tList2Sub, Ts = Ts,
                                     rho = rhoSub, SigRhoiList = SigRhoiList2Sub,
                                     alpha = alphaSub, betaStar = betaStarSub, SigmaStar = SigmaStarSub, 
                                     sig20 = sig202Sub, deltaRho = 0.03)
  
  betaStarCollect[[i]] <- duplicate(betaStar,shallow = TRUE)
  SigmaStarCollect[[i]] <- duplicate(SigmaStar,shallow = TRUE)
  sig201Collect[[i]] <- duplicate(sig201,shallow = TRUE)
  sig202Collect[[i]] <- duplicate(sig202,shallow = TRUE)
  alphaCollect[[i]] <- duplicate(alpha,shallow = TRUE)
  rhoCollect[[i]] <- duplicate(rho,shallow = TRUE)
  # Sub
  betaStarCollectSub[[i]] <- duplicate(betaStarSub,shallow = TRUE)
  SigmaStarCollectSub[[i]] <- duplicate(SigmaStarSub,shallow = TRUE)
  sig201CollectSub[[i]] <- duplicate(sig201Sub,shallow = TRUE)
  sig202CollectSub[[i]] <- duplicate(sig202Sub,shallow = TRUE)
  alphaCollectSub[[i]] <- duplicate(alphaSub,shallow = TRUE)
  rhoCollectSub[[i]] <- duplicate(rhoSub,shallow = TRUE)
}

# The obtained lists are the posterior samples given by the direct comibnation method
```  


```{r}
# using the results given by the direct combination method, we train the data selection model
set.seed(1)
p1L <- c()
Z1L <- list()

alphaCollectSub <- list()
betaStarCollectSub <- list()
SigmaStarCollectSub <- list()
sig201CollectSub <- list()
sig202CollectSub <- list()
rhoCollectSub <- list()

alphaCollect <- list()
betaStarCollect <- list()
SigmaStarCollect <- list()
sig201Collect <- list()
sig202Collect <- list()
rhoCollect <- list()

Z1 <- rep(1,nExt)
cpst <- 1

pb = txtProgressBar(min = 0, max = niterOut, style = 3)

for(i in 1:niterOut){
  Z0Trans <- Z1
  Z1Trans <- Z1
  
  # the proposal procedure, we choose two external subsets and 
  # evaluate the marginal likelihood thereof
  ratio <- runif(1,0,0.5)
  idx0 <- which(Z0Trans == 0)
  r0 <- ceiling(length(idx0) * ratio)
  if(length(idx0) > 1){
    idx0New <- sample(idx0,r0,replace = FALSE)
  }else{
    idx0New <- idx0
  }
  Z0Trans[idx0New] <- 1
  idxZ0Trans <- which(Z0Trans == 1)
  
  idx1 <- which(Z1Trans == 1)
  r1 <- ceiling(length(idx1) * ratio)
  if(length(idx1) > 1){
    idx1New <- sample(idx1,r1,replace = FALSE)
    Z1Trans[idx1New] <- 0
  }else{
    # if too few samples remain, try increasing the selected external data
    idx0 <- which(Z1Trans == 0)
    r0 <- ceiling(length(idx0) * ratio)
    idx0New <- sample(idx0,r0,replace = FALSE)
    Z1Trans[idx0New] <- 1
  }
  idxZ1Trans <- which(Z1Trans == 1)
  
  idxOrigin <- which(Z1 == 1)
  
  # the marginal likelihood estimation of the two competitive external subsets
  # and the original model
  idxZ0Trans <- which(Z0Trans == 1)
  idxZ1Trans <- which(Z1Trans == 1)
  idxOrigin <- which(Z1 == 1)
  
  set.seed(1)
  tList1SubNew <- tList1Sub[idxOrigin]
  YList1SubNew <- YList1Sub[idxOrigin]
  
  mlOrigin <- getMLCondParamsHetero(YListS = YList1SubNew, tListS = tList1SubNew,
                                    YListT = YList2Sub, tListT = tList2Sub,
                                    Ts = Ts, nburn = nburn, niter = niter, deltaAlpha = Ts/60,
                                    beta0 = beta0, nu0 = nu0, Psi0 = Psi0,
                                    a0 = a0, b0 = b0, rho = rhoSub, 
                                    alpha = alphaSub, betaStar = betaStarSub, 
                                    SigmaStar = SigmaStarSub, 
                                    sig20S = sig201Sub, sig20T = sig202Sub, deltaRho = 0.03)
  
  set.seed(1)
  tList1SubNew <- tList1Sub[idxZ0Trans]
  YList1SubNew <- YList1Sub[idxZ0Trans]
  
  ml0 <- getMLCondParamsHetero(YListS = YList1SubNew, tListS = tList1SubNew,
                               YListT = YList2Sub, tListT = tList2Sub,
                               Ts = Ts, nburn = nburn, niter = niter, deltaAlpha = Ts/60,
                               beta0 = beta0, nu0 = nu0, Psi0 = Psi0,
                               a0 = a0, b0 = b0, rho = rhoSub, 
                               alpha = alphaSub, betaStar = betaStarSub, 
                               SigmaStar = SigmaStarSub, 
                               sig20S = sig201Sub, sig20T = sig202Sub, deltaRho = 0.03)
  
  set.seed(1)
  tList1SubNew <- tList1Sub[idxZ1Trans]
  YList1SubNew <- YList1Sub[idxZ1Trans]
  
  ml1 <- getMLCondParamsHetero(YListS = YList1SubNew, tListS = tList1SubNew,
                               YListT = YList2Sub, tListT = tList2Sub, 
                               Ts = Ts, nburn = nburn, niter = niter, deltaAlpha = Ts/60,
                               beta0 = beta0, nu0 = nu0, Psi0 = Psi0,
                               a0 = a0, b0 = b0, rho = rhoSub, 
                               alpha = alphaSub, betaStar = betaStarSub, 
                               SigmaStar = SigmaStarSub, 
                               sig20S = sig201Sub, sig20T = sig202Sub, deltaRho = 0.03)
  
  logprob <- c(cpst * (ml0 - mlOrigin),
               cpst * (ml1 - mlOrigin),
               0)
  
  prob <- exp(logprob - max(logprob))
  
  label <- sample(1:3,1,prob = prob)
  
  if(label == 1){
    Z1 <- Z0Trans
  }else if(label == 2){
    Z1 <- Z1Trans
  }else{
    # pass
  }
  
  # combine the selected external subset with the internal data and take posterior samples
  tList1New <- tList1[which(Z1 == 1)]
  YList1New <- YList1[which(Z1 == 1)]
  
  if(length(tList1New) > 0){
    SigRhoiList1 <- list()
    for(iAr in 1:length(tList1New)){
      SigRhoiList1[[iAr]] <- arMat(rho = rho[1,1],tListi = tList1New[[iAr]])
    }
    
    tList1NewSub <- tList1Sub[which(Z1 == 1)]
    YList1NewSub <- YList1Sub[which(Z1 == 1)]
    
    SigRhoiList1Sub <- list()
    for(iAr in 1:length(tList1NewSub)){
      SigRhoiList1Sub[[iAr]] <- arMat(rho = rhoSub[1,1],tListi = tList1NewSub[[iAr]])
    }    
  }
  
  
  for(j in 1:nSamp){
    
    XList1New <- getXList(tList = tList1New, alpha = alpha[1,1], Ts = Ts)
    
    XList2 <- getXList(tList = tList2, alpha = alpha[1,1], Ts = Ts)
    
    XList1NewSub <- getXList(tList = tList1NewSub, alpha = alphaSub[1,1], Ts = Ts)
    
    XList2Sub <- getXList(tList = tList2Sub, alpha = alphaSub[1,1], Ts = Ts)
    
    # update everything except for alpha
    getSampMixEffectHetero(YListS = YList1New, XListS = XList1New,
                           YListT = YList2, XListT = XList2,
                           beta0 = beta0, nu0 = nu0, Psi0 = Psi0,
                           a0 = a0, b0 = b0, 
                           SigRhoiListS = SigRhoiList1, SigRhoiListT = SigRhoiList2, 
                           betaStar = betaStar, SigmaStar = SigmaStar, 
                           sig20S = sig201, sig20T = sig202)
    
    getSampMixEffectHetero(YListS = YList1NewSub,XListS = XList1NewSub,
                           YListT = YList2Sub,XListT = XList2Sub,
                           beta0 = beta0, nu0 = nu0, Psi0 = Psi0,
                           a0 = a0, b0 = b0, 
                           SigRhoiListS = SigRhoiList1Sub, SigRhoiListT = SigRhoiList2Sub, 
                           betaStar = betaStarSub, SigmaStar = SigmaStarSub, 
                           sig20S = sig201Sub, sig20T = sig202Sub)
    
    # update Alpha
    getAlphaMixEffectHetero(YListS = YList1New, XListS = XList1New, tListS = tList1New, 
                            YListT = YList2, XListT = XList2, tListT = tList2, 
                            Ts = Ts, alpha = alpha, 
                            SigRhoiListS = SigRhoiList1, SigRhoiListT = SigRhoiList2, 
                            betaStar = betaStar, SigmaStar = SigmaStar, 
                            sig20S = sig201, sig20T = sig202, deltaAlpha = Ts/60)
    
    getAlphaMixEffectHetero(YListS = YList1NewSub, XListS = XList1NewSub, tListS = tList1NewSub, 
                            YListT = YList2Sub, XListT = XList2Sub, tListT = tList2Sub, 
                            Ts = Ts, alpha = alphaSub, 
                            SigRhoiListS = SigRhoiList1Sub, SigRhoiListT = SigRhoiList2Sub, 
                            betaStar = betaStarSub, SigmaStar = SigmaStarSub, 
                            sig20S = sig202Sub, sig20T = sig201Sub, deltaAlpha = Ts/60)
    
    # update rho
    SigRhoiList1 <- getRhoMixEffect(YList = YList1New, tList = tList1New, Ts = Ts, 
                                    rho = rho, SigRhoiList = SigRhoiList1, 
                                    alpha = alpha, betaStar = betaStar, SigmaStar = SigmaStar, 
                                    sig20 = sig201, deltaRho = 0.03)
    
    SigRhoiList2 <- getRhoMixEffect(YList = YList2, tList = tList2, Ts = Ts, 
                                    rho = rho, SigRhoiList = SigRhoiList2, 
                                    alpha = alpha, betaStar = betaStar, SigmaStar = SigmaStar, 
                                    sig20 = sig202, deltaRho = 0.03)
    # Sub
    SigRhoiList1Sub <- getRhoMixEffect(YList = YList1NewSub, tList = tList1NewSub, Ts = Ts,
                                       rho = rhoSub, SigRhoiList = SigRhoiList1Sub,
                                       alpha = alphaSub, betaStar = betaStarSub, SigmaStar = SigmaStarSub, 
                                       sig20 = sig201Sub, deltaRho = 0.03)
    
    SigRhoiList2Sub <- getRhoMixEffect(YList = YList2Sub, tList = tList2Sub, Ts = Ts,
                                       rho = rhoSub, SigRhoiList = SigRhoiList2Sub,
                                       alpha = alphaSub, betaStar = betaStarSub, SigmaStar = SigmaStarSub, 
                                       sig20 = sig202Sub, deltaRho = 0.03)
    
  }
  
  alphaCollect[[i]] <- duplicate(alpha,shallow = TRUE)
  betaStarCollect[[i]] <- duplicate(betaStar,shallow = TRUE)
  SigmaStarCollect[[i]] <- duplicate(SigmaStar,shallow = TRUE)
  sig201Collect[[i]] <- duplicate(sig201,shallow = TRUE)
  sig202Collect[[i]] <- duplicate(sig202,shallow = TRUE)
  rhoCollect[[i]] <- duplicate(rho,shallow = TRUE)
  
  alphaCollectSub[[i]] <- duplicate(alphaSub,shallow = TRUE)
  betaStarCollectSub[[i]] <- duplicate(betaStarSub,shallow = TRUE)
  SigmaStarCollectSub[[i]] <- duplicate(SigmaStarSub,shallow = TRUE)
  sig201CollectSub[[i]] <- duplicate(sig201Sub,shallow = TRUE)
  sig202CollectSub[[i]] <- duplicate(sig202Sub,shallow = TRUE)
  rhoCollectSub[[i]] <- duplicate(rhoSub,shallow = TRUE)
  
  Z1L[[i]] <- duplicate(Z1,shallow = TRUE)
  p1L[i] <- sum(Z1L[[i]])/length(Z1L[[i]])
  
  setTxtProgressBar(pb,i)
}

close(pb)

```  

## Reproduce DGP4

Consider the case when $K = 20, \rho = 0.5$, the simulation data can be generated using the following code,

### Data preparation
```{r}
# To reproduce the Table 1 result, one needs to set.seed from 1 to 100
set.seed(1)

# define external parameters
Ts1 <- 120
alpha1 <- matrix(60,nrow = 1,ncol = 1)
n1 <- 10
theta1 <- c(20,1,10,-0.1,8)

Tsw <- 120
alphaw <- matrix(60,nrow = 1,ncol = 1)
nw <- 10
# this is the part different from the previous setting
thetaw <- c(10,4,20,-1,12)

# construct external trajectory lists
tList1 <- list()
nList1 <- list()
XList1 <- list()
YList1 <- list()

for(i in 1:n1){
  ni <- rpois(1,lambda = 20)
  tList1[[i]] <- matrix(sort(runif(ni,min = 0,max = Ts1)),ncol = 1)
  nList1[[i]] <- ni
}

XList1 <- getXList(tList1,alpha1[1,1],Ts1)
thetaMat1 <- matrix(0,nrow = n1 + nw,ncol = 5)
SigMat1 <- diag(c(abs(c(25,0.1,9,0.1,4))))

for(i in 1:n1){
  ni <- length(tList1[[i]])
  thetai <- tmvtnorm::rtmvnorm(1,mean = theta1,sigma = SigMat1)
  thetaMat1[i,] <- thetai
  epsMat <- arMat(rho = 0.5,tListi = tList1[[i]])
  eps <- mvtnorm::rmvnorm(1,mean = rep(0,ni),sigma = 4*epsMat)
  
  YList1[[i]] <- matrix(c(XList1[[i]]%*%matrix(thetai,ncol = 1)) + c(eps), ncol = 1) 
  
}

for(i in (n1+1):(n1 + nw)){
  ni <- rpois(1,lambda = 20)
  tList1[[i]] <- matrix(sort(runif(ni,min = 0,max = Tsw)),ncol = 1)
  nList1[[i]] <- ni
}

XList1 <- getXList(tList1,alphaw[1,1],Tsw)
SigMatw <- diag(c(abs(c(25,0.1,9,0.1,4))))

for(i in (n1+1):(n1 + nw)){
  ni <- length(tList1[[i]])
  thetai <- tmvtnorm::rtmvnorm(1,mean = thetaw,sigma = SigMatw)
  thetaMat1[i,] <- thetai
  
  epsMat <- arMat(rho = 0.5,tListi = tList1[[i]])
  eps <- mvtnorm::rmvnorm(1,mean = rep(0,ni),sigma = 4*epsMat)
  
  YList1[[i]] <- matrix(c(XList1[[i]]%*%matrix(thetai,ncol = 1)) + c(eps), ncol = 1) 
  
}

phaseExt <- matrix(0,nrow = sum(unlist(nList1)),ncol = 4)

n1count <- 0
for(i in 1:(n1 + nw)){
  ni <- nList1[[i]]
  phaseExt[(n1count + 1):(n1count + ni),1] <- rep(i,ni)
  phaseExt[(n1count + 1):(n1count + ni),2] <- tList1[[i]]
  phaseExt[(n1count + 1):(n1count + ni),3] <- YList1[[i]]
  phaseExt[(n1count + 1):(n1count + ni),4] <- rep("External",ni)
  n1count <- n1count + ni
}

phaseExt <- as.data.frame(phaseExt)
colnames(phaseExt) <- c("psuedo_id","TimeW","Value","Phase")
phaseExt$psuedo_id <- as.numeric(phaseExt$psuedo_id)
phaseExt$TimeW <- as.numeric(phaseExt$TimeW)
phaseExt$Value <- as.numeric(phaseExt$Value)
```  

```{r}
# define internal parameters
Ts2 <- 120
alpha2 <- matrix(60,nrow = 1,ncol = 1)
n2 <- 40
theta2 <- c(20,1,10,-0.1,8)

# construct internal trajectory lists
tList2 <- list()
nList2 <- list()
XList2 <- list()
YList2 <- list()

for(i in 1:n2){
  ni <- rpois(1,lambda = 20)
  # truncated before 40
  tList2[[i]] <- matrix(sort(runif(ni,min = 0,max = 60)),ncol = 1)
  nList2[[i]] <- ni
}

XList2 <- getXList(tList2,alpha2[1,1],Ts2)
thetaMat2 <- matrix(0,nrow = n2,ncol = 5)
SigMat2 <- diag(c(abs(c(25,0.1,9,0.1,4))))

for(i in 1:n2){
  ni <- length(tList2[[i]])
  thetai <- tmvtnorm::rtmvnorm(1,mean = theta2,sigma = SigMat2)
  thetaMat2[i,] <- thetai
  
  epsMat <- arMat(rho = 0.5,tListi = tList2[[i]])
  eps <- mvtnorm::rmvnorm(1,mean = rep(0,ni),sigma = 4*epsMat)
  
  YList2[[i]] <- matrix(c(XList2[[i]]%*%matrix(thetai,ncol = 1)) + c(eps), ncol = 1) 
  
}

phaseInt <- matrix(0,nrow = sum(unlist(nList2)),ncol = 4)

n2count <- 0
for(i in 1:n2){
  ni <- nList2[[i]]
  phaseInt[(n2count + 1):(n2count + ni),1] <- as.numeric(rep(i,ni))
  phaseInt[(n2count + 1):(n2count + ni),2] <- as.numeric(tList2[[i]])
  phaseInt[(n2count + 1):(n2count + ni),3] <- as.numeric(YList2[[i]])
  phaseInt[(n2count + 1):(n2count + ni),4] <- rep("Internal",ni)
  n2count <- n2count + ni
}

phaseInt <- as.data.frame(phaseInt)
colnames(phaseInt) <- c("psuedo_id","TimeW","Value","Phase")
phaseInt$psuedo_id <- as.numeric(phaseInt$psuedo_id)
phaseInt$TimeW <- as.numeric(phaseInt$TimeW)
phaseInt$Value <- as.numeric(phaseInt$Value)
```  

```{r}
# conduct z-transformation with starting value
# conduct z-transform
mVal <- mean(phaseInt$Value[which(phaseInt$TimeW <= 10)])
sdVal <- sd(phaseInt$Value[which(phaseInt$TimeW <= 10)])

phaseInt$Value <- (phaseInt$Value - mean(phaseInt$Value[which(phaseInt$TimeW <= 10)]))/
  sd(phaseInt$Value[which(phaseInt$TimeW <= 10)])
phaseExt$Value <- (phaseExt$Value - mean(phaseExt$Value[which(phaseExt$TimeW <= 10)]))/
  sd(phaseExt$Value[which(phaseExt$TimeW <= 10)])
```  

```{r}
# construct lists for the external and internal trajectories prior to
# a chosen time point. For simulation, this time point is chosen to be 60
tList1Sub <- list()
YList1Sub <- list()
tList2Sub <- list()
YList2Sub <- list()

TsThres <- 60
nExt <- 20
count <- 1
for(i in 1:nExt){
  tList1[[i]] <- matrix(phaseExt$TimeW[which(phaseExt$psuedo_id == i)],ncol = 1)
  YList1[[i]] <- matrix(phaseExt$Value[which(phaseExt$psuedo_id == i)],ncol = 1)
  
  idx <- which(tList1[[i]] <= TsThres)
  if(length(idx) > 0){
    tList1Sub[[count]] <- tList1[[i]][idx,,drop = FALSE]
    YList1Sub[[count]] <- YList1[[i]][idx,,drop = FALSE]
    count <- count + 1
  }
}

nInt <- 40
count <- 1
for(i in 1:nInt){
  tList2[[i]] <- matrix(phaseInt$TimeW[which(phaseInt$psuedo_id == i)],ncol = 1)
  YList2[[i]] <- matrix(phaseInt$Value[which(phaseInt$psuedo_id == i)],ncol = 1)
  
  idx <- which(tList2[[i]] <= TsThres)
  if(length(idx) > 0){
    tList2Sub[[count]] <- tList2[[i]][idx,,drop = FALSE]
    YList2Sub[[count]] <- YList2[[i]][idx,,drop = FALSE]
    count <- count + 1
  }
}
```  

### Model pretraining

To pretrain the model, we use the values given by the direct combination method as the initial value of the data selection method.

```{r}
# seed value can be fixed to 1
set.seed(1)
niter <- 2e3
nburn <- 1e3
niterOut <- 1e3
nSamp <- 1e3

Ts <- 120
beta0 <- matrix(0,nrow = 5,ncol = 1)
nu0 <-  1e-2
Psi0 <- diag(5) * 1e2
a0 <- 1e-2
b0 <- 1e-2

# train both subset
betaStarSub <- matrix(0,nrow = 5,ncol = 1)
SigmaStarSub <- diag(5)
sig201Sub <- matrix(1,nrow = 1,ncol = 1)
sig202Sub <- matrix(1,nrow = 1,ncol = 1)
alphaSub <- matrix(60,nrow = 1,ncol = 1)
rhoSub <- matrix(0.2,nrow = 1,ncol = 1)

alphaCollectSub <- list()
betaStarCollectSub <- list()
SigmaStarCollectSub <- list()
sig201CollectSub <- list()
sig202CollectSub <- list()
rhoCollectSub <- list()

# and complete data
betaStar <- matrix(0,nrow = 5,ncol = 1)
SigmaStar <- diag(5)

sig201 <- matrix(1,nrow = 1,ncol = 1)
sig202 <- matrix(1,nrow = 1,ncol = 1)

alpha <- matrix(60,nrow = 1,ncol = 1)
rho <- matrix(0.2,nrow = 1,ncol = 1)

alphaCollect <- list()
betaStarCollect <- list()
SigmaStarCollect <- list()
sig201Collect <- list()
sig202Collect <- list()
rhoCollect <- list()

SigRhoiList1 <- list()
SigRhoiList1Sub <- list()

for(i in 1:nExt){
  SigRhoiList1[[i]] <- arMat(rho = rho[1,1],tListi = tList1[[i]])
  SigRhoiList1Sub[[i]] <- arMat(rho = rhoSub[1,1],tListi = tList1Sub[[i]])
}

SigRhoiList2 <- list()
SigRhoiList2Sub <- list()

for(i in 1:nInt){
  SigRhoiList2[[i]] <- arMat(rho = rho[1,1],tListi = tList2[[i]])
  SigRhoiList2Sub[[i]] <- arMat(rho = rhoSub[1,1],tListi = tList2Sub[[i]])
}

####
# initialization
for(i in 1:niter){
  
  XList1 <- getXList(tList = tList1, alpha = alpha[1,1], Ts = Ts)
  
  XList2 <- getXList(tList = tList2, alpha = alpha[1,1], Ts = Ts)
  
  XList1Sub <- getXList(tList = tList1Sub, alpha = alphaSub[1,1], Ts = Ts)
  
  XList2Sub <- getXList(tList = tList2Sub, alpha = alphaSub[1,1], Ts = Ts)
  
  # update everything except for alpha
  getSampMixEffectHetero(YListS = YList1, XListS = XList1,
                         YListT = YList2, XListT = XList2,
                         beta0 = beta0, nu0 = nu0, Psi0 = Psi0,
                         a0 = a0, b0 = b0, 
                         SigRhoiListS = SigRhoiList1, SigRhoiListT = SigRhoiList2, 
                         betaStar = betaStar, SigmaStar = SigmaStar, 
                         sig20S = sig201, sig20T = sig202)
  
  getSampMixEffectHetero(YListS = YList1Sub,XListS = XList1Sub,
                         YListT = YList2Sub,XListT = XList2Sub,
                         beta0 = beta0, nu0 = nu0, Psi0 = Psi0,
                         a0 = a0, b0 = b0, 
                         SigRhoiListS = SigRhoiList1Sub, SigRhoiListT = SigRhoiList2Sub, 
                         betaStar = betaStarSub, SigmaStar = SigmaStarSub, 
                         sig20S = sig201Sub, sig20T = sig202Sub)
  
  # update Alpha
  getAlphaMixEffectHetero(YListS = YList1, XListS = XList1, tListS = tList1, 
                          YListT = YList2, XListT = XList2, tListT = tList2, 
                          Ts = Ts, alpha = alpha, 
                          SigRhoiListS = SigRhoiList1, SigRhoiListT = SigRhoiList2, 
                          betaStar = betaStar, SigmaStar = SigmaStar, 
                          sig20S = sig201, sig20T = sig202, deltaAlpha = Ts/60)
  
  getAlphaMixEffectHetero(YListS = YList1Sub, XListS = XList1Sub, tListS = tList1Sub, 
                          YListT = YList2Sub, XListT = XList2Sub, tListT = tList2Sub, 
                          Ts = Ts, alpha = alphaSub, 
                          SigRhoiListS = SigRhoiList1Sub, SigRhoiListT = SigRhoiList2Sub, 
                          betaStar = betaStarSub, SigmaStar = SigmaStarSub, 
                          sig20S = sig201Sub, sig20T = sig202Sub, deltaAlpha = Ts/60)
  
  # update rho
  SigRhoiList1 <- getRhoMixEffect(YList = YList1, tList = tList1, Ts = Ts, 
                                  rho = rho, SigRhoiList = SigRhoiList1, 
                                  alpha = alpha, betaStar = betaStar, SigmaStar = SigmaStar, 
                                  sig20 = sig201, deltaRho = 0.03)
  
  SigRhoiList2 <- getRhoMixEffect(YList = YList2, tList = tList2, Ts = Ts, 
                                  rho = rho, SigRhoiList = SigRhoiList2, 
                                  alpha = alpha, betaStar = betaStar, SigmaStar = SigmaStar, 
                                  sig20 = sig202, deltaRho = 0.03)
  # Sub
  SigRhoiList1Sub <- getRhoMixEffect(YList = YList1Sub, tList = tList1Sub, Ts = Ts,
                                     rho = rhoSub, SigRhoiList = SigRhoiList1Sub,
                                     alpha = alphaSub, betaStar = betaStarSub, SigmaStar = SigmaStarSub, 
                                     sig20 = sig201Sub, deltaRho = 0.03)
  
  SigRhoiList2Sub <- getRhoMixEffect(YList = YList2Sub, tList = tList2Sub, Ts = Ts,
                                     rho = rhoSub, SigRhoiList = SigRhoiList2Sub,
                                     alpha = alphaSub, betaStar = betaStarSub, SigmaStar = SigmaStarSub, 
                                     sig20 = sig202Sub, deltaRho = 0.03)
  
  betaStarCollect[[i]] <- duplicate(betaStar,shallow = TRUE)
  SigmaStarCollect[[i]] <- duplicate(SigmaStar,shallow = TRUE)
  sig201Collect[[i]] <- duplicate(sig201,shallow = TRUE)
  sig202Collect[[i]] <- duplicate(sig202,shallow = TRUE)
  alphaCollect[[i]] <- duplicate(alpha,shallow = TRUE)
  rhoCollect[[i]] <- duplicate(rho,shallow = TRUE)
  # Sub
  betaStarCollectSub[[i]] <- duplicate(betaStarSub,shallow = TRUE)
  SigmaStarCollectSub[[i]] <- duplicate(SigmaStarSub,shallow = TRUE)
  sig201CollectSub[[i]] <- duplicate(sig201Sub,shallow = TRUE)
  sig202CollectSub[[i]] <- duplicate(sig202Sub,shallow = TRUE)
  alphaCollectSub[[i]] <- duplicate(alphaSub,shallow = TRUE)
  rhoCollectSub[[i]] <- duplicate(rhoSub,shallow = TRUE)
}

# The obtained lists are the posterior samples given by the direct comibnation method
```  


```{r}
# using the results given by the direct combination method, we train the data selection model
set.seed(1)
p1L <- c()
Z1L <- list()

alphaCollectSub <- list()
betaStarCollectSub <- list()
SigmaStarCollectSub <- list()
sig201CollectSub <- list()
sig202CollectSub <- list()
rhoCollectSub <- list()

alphaCollect <- list()
betaStarCollect <- list()
SigmaStarCollect <- list()
sig201Collect <- list()
sig202Collect <- list()
rhoCollect <- list()

Z1 <- rep(1,nExt)
cpst <- 1

pb = txtProgressBar(min = 0, max = niterOut, style = 3)

for(i in 1:niterOut){
  Z0Trans <- Z1
  Z1Trans <- Z1
  
  # the proposal procedure, we choose two external subsets and 
  # evaluate the marginal likelihood thereof
  ratio <- runif(1,0,0.5)
  idx0 <- which(Z0Trans == 0)
  r0 <- ceiling(length(idx0) * ratio)
  if(length(idx0) > 1){
    idx0New <- sample(idx0,r0,replace = FALSE)
  }else{
    idx0New <- idx0
  }
  Z0Trans[idx0New] <- 1
  idxZ0Trans <- which(Z0Trans == 1)
  
  idx1 <- which(Z1Trans == 1)
  r1 <- ceiling(length(idx1) * ratio)
  if(length(idx1) > 1){
    idx1New <- sample(idx1,r1,replace = FALSE)
    Z1Trans[idx1New] <- 0
  }else{
    # if too few samples remain, try increasing the selected external data
    idx0 <- which(Z1Trans == 0)
    r0 <- ceiling(length(idx0) * ratio)
    idx0New <- sample(idx0,r0,replace = FALSE)
    Z1Trans[idx0New] <- 1
  }
  idxZ1Trans <- which(Z1Trans == 1)
  
  idxOrigin <- which(Z1 == 1)
  
  # the marginal likelihood estimation of the two competitive external subsets
  # and the original model
  idxZ0Trans <- which(Z0Trans == 1)
  idxZ1Trans <- which(Z1Trans == 1)
  idxOrigin <- which(Z1 == 1)
  
  set.seed(1)
  tList1SubNew <- tList1Sub[idxOrigin]
  YList1SubNew <- YList1Sub[idxOrigin]
  
  mlOrigin <- getMLCondParamsHetero(YListS = YList1SubNew, tListS = tList1SubNew,
                                    YListT = YList2Sub, tListT = tList2Sub,
                                    Ts = Ts, nburn = nburn, niter = niter, deltaAlpha = Ts/60,
                                    beta0 = beta0, nu0 = nu0, Psi0 = Psi0,
                                    a0 = a0, b0 = b0, rho = rhoSub, 
                                    alpha = alphaSub, betaStar = betaStarSub, 
                                    SigmaStar = SigmaStarSub, 
                                    sig20S = sig201Sub, sig20T = sig202Sub, deltaRho = 0.03)
  
  set.seed(1)
  tList1SubNew <- tList1Sub[idxZ0Trans]
  YList1SubNew <- YList1Sub[idxZ0Trans]
  
  ml0 <- getMLCondParamsHetero(YListS = YList1SubNew, tListS = tList1SubNew,
                               YListT = YList2Sub, tListT = tList2Sub,
                               Ts = Ts, nburn = nburn, niter = niter, deltaAlpha = Ts/60,
                               beta0 = beta0, nu0 = nu0, Psi0 = Psi0,
                               a0 = a0, b0 = b0, rho = rhoSub, 
                               alpha = alphaSub, betaStar = betaStarSub, 
                               SigmaStar = SigmaStarSub, 
                               sig20S = sig201Sub, sig20T = sig202Sub, deltaRho = 0.03)
  
  set.seed(1)
  tList1SubNew <- tList1Sub[idxZ1Trans]
  YList1SubNew <- YList1Sub[idxZ1Trans]
  
  ml1 <- getMLCondParamsHetero(YListS = YList1SubNew, tListS = tList1SubNew,
                               YListT = YList2Sub, tListT = tList2Sub, 
                               Ts = Ts, nburn = nburn, niter = niter, deltaAlpha = Ts/60,
                               beta0 = beta0, nu0 = nu0, Psi0 = Psi0,
                               a0 = a0, b0 = b0, rho = rhoSub, 
                               alpha = alphaSub, betaStar = betaStarSub, 
                               SigmaStar = SigmaStarSub, 
                               sig20S = sig201Sub, sig20T = sig202Sub, deltaRho = 0.03)
  
  logprob <- c(cpst * (ml0 - mlOrigin),
               cpst * (ml1 - mlOrigin),
               0)
  
  prob <- exp(logprob - max(logprob))
  
  label <- sample(1:3,1,prob = prob)
  
  if(label == 1){
    Z1 <- Z0Trans
  }else if(label == 2){
    Z1 <- Z1Trans
  }else{
    # pass
  }
  
  # combine the selected external subset with the internal data and take posterior samples
  tList1New <- tList1[which(Z1 == 1)]
  YList1New <- YList1[which(Z1 == 1)]
  
  if(length(tList1New) > 0){
    SigRhoiList1 <- list()
    for(iAr in 1:length(tList1New)){
      SigRhoiList1[[iAr]] <- arMat(rho = rho[1,1],tListi = tList1New[[iAr]])
    }
    
    tList1NewSub <- tList1Sub[which(Z1 == 1)]
    YList1NewSub <- YList1Sub[which(Z1 == 1)]
    
    SigRhoiList1Sub <- list()
    for(iAr in 1:length(tList1NewSub)){
      SigRhoiList1Sub[[iAr]] <- arMat(rho = rhoSub[1,1],tListi = tList1NewSub[[iAr]])
    }    
  }
  
  
  for(j in 1:nSamp){
    
    XList1New <- getXList(tList = tList1New, alpha = alpha[1,1], Ts = Ts)
    
    XList2 <- getXList(tList = tList2, alpha = alpha[1,1], Ts = Ts)
    
    XList1NewSub <- getXList(tList = tList1NewSub, alpha = alphaSub[1,1], Ts = Ts)
    
    XList2Sub <- getXList(tList = tList2Sub, alpha = alphaSub[1,1], Ts = Ts)
    
    # update everything except for alpha
    getSampMixEffectHetero(YListS = YList1New, XListS = XList1New,
                           YListT = YList2, XListT = XList2,
                           beta0 = beta0, nu0 = nu0, Psi0 = Psi0,
                           a0 = a0, b0 = b0, 
                           SigRhoiListS = SigRhoiList1, SigRhoiListT = SigRhoiList2, 
                           betaStar = betaStar, SigmaStar = SigmaStar, 
                           sig20S = sig201, sig20T = sig202)
    
    getSampMixEffectHetero(YListS = YList1NewSub,XListS = XList1NewSub,
                           YListT = YList2Sub,XListT = XList2Sub,
                           beta0 = beta0, nu0 = nu0, Psi0 = Psi0,
                           a0 = a0, b0 = b0, 
                           SigRhoiListS = SigRhoiList1Sub, SigRhoiListT = SigRhoiList2Sub, 
                           betaStar = betaStarSub, SigmaStar = SigmaStarSub, 
                           sig20S = sig201Sub, sig20T = sig202Sub)
    
    # update Alpha
    getAlphaMixEffectHetero(YListS = YList1New, XListS = XList1New, tListS = tList1New, 
                            YListT = YList2, XListT = XList2, tListT = tList2, 
                            Ts = Ts, alpha = alpha, 
                            SigRhoiListS = SigRhoiList1, SigRhoiListT = SigRhoiList2, 
                            betaStar = betaStar, SigmaStar = SigmaStar, 
                            sig20S = sig201, sig20T = sig202, deltaAlpha = Ts/60)
    
    getAlphaMixEffectHetero(YListS = YList1NewSub, XListS = XList1NewSub, tListS = tList1NewSub, 
                            YListT = YList2Sub, XListT = XList2Sub, tListT = tList2Sub, 
                            Ts = Ts, alpha = alphaSub, 
                            SigRhoiListS = SigRhoiList1Sub, SigRhoiListT = SigRhoiList2Sub, 
                            betaStar = betaStarSub, SigmaStar = SigmaStarSub, 
                            sig20S = sig202Sub, sig20T = sig201Sub, deltaAlpha = Ts/60)
    
    # update rho
    SigRhoiList1 <- getRhoMixEffect(YList = YList1New, tList = tList1New, Ts = Ts, 
                                    rho = rho, SigRhoiList = SigRhoiList1, 
                                    alpha = alpha, betaStar = betaStar, SigmaStar = SigmaStar, 
                                    sig20 = sig201, deltaRho = 0.03)
    
    SigRhoiList2 <- getRhoMixEffect(YList = YList2, tList = tList2, Ts = Ts, 
                                    rho = rho, SigRhoiList = SigRhoiList2, 
                                    alpha = alpha, betaStar = betaStar, SigmaStar = SigmaStar, 
                                    sig20 = sig202, deltaRho = 0.03)
    # Sub
    SigRhoiList1Sub <- getRhoMixEffect(YList = YList1NewSub, tList = tList1NewSub, Ts = Ts,
                                       rho = rhoSub, SigRhoiList = SigRhoiList1Sub,
                                       alpha = alphaSub, betaStar = betaStarSub, SigmaStar = SigmaStarSub, 
                                       sig20 = sig201Sub, deltaRho = 0.03)
    
    SigRhoiList2Sub <- getRhoMixEffect(YList = YList2Sub, tList = tList2Sub, Ts = Ts,
                                       rho = rhoSub, SigRhoiList = SigRhoiList2Sub,
                                       alpha = alphaSub, betaStar = betaStarSub, SigmaStar = SigmaStarSub, 
                                       sig20 = sig202Sub, deltaRho = 0.03)
    
  }
  
  alphaCollect[[i]] <- duplicate(alpha,shallow = TRUE)
  betaStarCollect[[i]] <- duplicate(betaStar,shallow = TRUE)
  SigmaStarCollect[[i]] <- duplicate(SigmaStar,shallow = TRUE)
  sig201Collect[[i]] <- duplicate(sig201,shallow = TRUE)
  sig202Collect[[i]] <- duplicate(sig202,shallow = TRUE)
  rhoCollect[[i]] <- duplicate(rho,shallow = TRUE)
  
  alphaCollectSub[[i]] <- duplicate(alphaSub,shallow = TRUE)
  betaStarCollectSub[[i]] <- duplicate(betaStarSub,shallow = TRUE)
  SigmaStarCollectSub[[i]] <- duplicate(SigmaStarSub,shallow = TRUE)
  sig201CollectSub[[i]] <- duplicate(sig201Sub,shallow = TRUE)
  sig202CollectSub[[i]] <- duplicate(sig202Sub,shallow = TRUE)
  rhoCollectSub[[i]] <- duplicate(rhoSub,shallow = TRUE)
  
  Z1L[[i]] <- duplicate(Z1,shallow = TRUE)
  p1L[i] <- sum(Z1L[[i]])/length(Z1L[[i]])
  
  setTxtProgressBar(pb,i)
}

close(pb)

```  

## Error evaluation

With the obtained betaStarCollect, we can evaluate the error with the following chunks,

```{r}
# transform to the original scale
beta1List <- c()
beta2List <- c()
beta3List <- c()
beta4List <- c()
beta5List <- c()
pSampList <- c()
for(j in (5e2+1):1e3){
  beta1List[j-5e2] <- betaStarCollect[[j]][1] * sdVal + mVal
  beta2List[j-5e2] <- betaStarCollect[[j]][2] * sdVal
  beta3List[j-5e2] <- betaStarCollect[[j]][3] * sdVal + mVal
  beta4List[j-5e2] <- betaStarCollect[[j]][4] * sdVal
  beta5List[j-5e2] <- betaStarCollect[[j]][5] * sdVal + mVal
  pSampList[j-5e2] <- mean(Z1L[[j]])
}

absLoss12List[i_seed] <- median(abs((beta1List - 20)/20) + abs((beta2List - 1)/1))
absLoss5List[i_seed] <- median(abs((beta5List - 8)/8))
pList[i_seed] <- median(pSampList)
```  

# Summary with the obtained results

Assume the results are arranged into a list of length 100, with each element containing a betaStarList and Z1L, defined similarly with those in the previous chunk. Suppose the results of the data selection method for DGP1 and DGP4 are named hemophiliaCorrectRho00n10 and hemophiliaWrongPlateauRho05n10. Also, suppose the results of the direct combination method for DGP1 and DGP4 are named hemophiliaCorrectCompRho00n10 and hemophiliaWrongPlateauCompRho05n10. The code shown as follows is for summary,

DGP1, $K = 20, \rho = 0$,

```{r}
path <- "your_path/DGP1"

fileName <- paste(path,"hemophiliaCorrectRho00n10",sep = "")
load(fileName)

outSelection <- outList

fileName <- paste(path,"hemophiliaCorrectCompRho00n10",sep = "")
load(fileName)

ZCount <- 10

outComp <- outList

absLoss12List <- c()
absLoss5List <- c()
pList <- c()
pDiffList <- c()

absLoss12CompList <- c()
absLoss5CompList <- c()

ifSmall <- c()

for(i_seed in 1:1e2){
  set.seed(i_seed)
  
  # D1
  #####
  Ts1 <- 120
  alpha1 <- matrix(60,nrow = 1,ncol = 1)
  n1 <- 10
  theta1 <- c(20,1,10,-0.1,8)
  
  # wrong D
  Tsw <- 120
  alphaw <- matrix(60,nrow = 1,ncol = 1)
  nw <- 10
  thetaw <- c(20,1,10,-0.1,8)
  
  tList1 <- list()
  nList1 <- list()
  XList1 <- list()
  YList1 <- list()
  
  for(i in 1:n1){
    ni <- rpois(1,lambda = 20)
    tList1[[i]] <- matrix(sort(runif(ni,min = 0,max = Ts1)),ncol = 1)
    nList1[[i]] <- ni
  }
  
  XList1 <- getXList(tList1,alpha1[1,1],Ts1)
  thetaMat1 <- matrix(0,nrow = n1 + nw,ncol = 5)
  SigMat1 <- diag(c(abs(c(25,0.1,9,0.1,4))))
  
  for(i in 1:n1){
    ni <- length(tList1[[i]])
    thetai <- tmvtnorm::rtmvnorm(1,mean = theta1,sigma = SigMat1)
    thetaMat1[i,] <- thetai
    epsMat <- arMat(rho = 0,tListi = tList1[[i]])
    eps <- mvtnorm::rmvnorm(1,mean = rep(0,ni),sigma = 4*epsMat)
    
    YList1[[i]] <- matrix(c(XList1[[i]]%*%matrix(thetai,ncol = 1)) + c(eps), ncol = 1) 
    
  }
  
  for(i in (n1+1):(n1 + nw)){
    ni <- rpois(1,lambda = 20)
    tList1[[i]] <- matrix(sort(runif(ni,min = 0,max = Tsw)),ncol = 1)
    nList1[[i]] <- ni
  }
  
  XList1 <- getXList(tList1,alphaw[1,1],Tsw)
  SigMatw <- diag(c(abs(c(25,0.1,9,0.1,4))))
  
  for(i in (n1+1):(n1 + nw)){
    ni <- length(tList1[[i]])
    thetai <- tmvtnorm::rtmvnorm(1,mean = thetaw,sigma = SigMatw)
    thetaMat1[i,] <- thetai
    
    epsMat <- arMat(rho = 0,tListi = tList1[[i]])
    eps <- mvtnorm::rmvnorm(1,mean = rep(0,ni),sigma = 4*epsMat)
    
    YList1[[i]] <- matrix(c(XList1[[i]]%*%matrix(thetai,ncol = 1)) + c(eps), ncol = 1) 
    
  }
  
  phaseExt <- matrix(0,nrow = sum(unlist(nList1)),ncol = 4)
  
  n1count <- 0
  for(i in 1:(n1 + nw)){
    ni <- nList1[[i]]
    phaseExt[(n1count + 1):(n1count + ni),1] <- rep(i,ni)
    phaseExt[(n1count + 1):(n1count + ni),2] <- tList1[[i]]
    phaseExt[(n1count + 1):(n1count + ni),3] <- YList1[[i]]
    phaseExt[(n1count + 1):(n1count + ni),4] <- rep("External",ni)
    n1count <- n1count + ni
  }
  
  phaseExt <- as.data.frame(phaseExt)
  colnames(phaseExt) <- c("psuedo_id","TimeW","Value","Phase")
  phaseExt$psuedo_id <- as.numeric(phaseExt$psuedo_id)
  phaseExt$TimeW <- as.numeric(phaseExt$TimeW)
  phaseExt$Value <- as.numeric(phaseExt$Value)
  
  #####
  # D2
  Ts2 <- 120
  alpha2 <- matrix(60,nrow = 1,ncol = 1)
  n2 <- 40
  theta2 <- c(20,1,10,-0.1,8)
  
  tList2 <- list()
  nList2 <- list()
  XList2 <- list()
  YList2 <- list()
  
  for(i in 1:n2){
    ni <- rpois(1,lambda = 20)
    # truncated before 40
    tList2[[i]] <- matrix(sort(runif(ni,min = 0,max = 60)),ncol = 1)
    nList2[[i]] <- ni
  }
  
  XList2 <- getXList(tList2,alpha2[1,1],Ts2)
  thetaMat2 <- matrix(0,nrow = n2,ncol = 5)
  SigMat2 <- diag(c(abs(c(25,0.1,9,0.1,4))))
  
  for(i in 1:n2){
    ni <- length(tList2[[i]])
    thetai <- tmvtnorm::rtmvnorm(1,mean = theta2,sigma = SigMat2)
    thetaMat2[i,] <- thetai
    
    epsMat <- arMat(rho = 0,tListi = tList2[[i]])
    eps <- mvtnorm::rmvnorm(1,mean = rep(0,ni),sigma = 4*epsMat)
    
    YList2[[i]] <- matrix(c(XList2[[i]]%*%matrix(thetai,ncol = 1)) + c(eps), ncol = 1) 
    
  }
  
  phaseInt <- matrix(0,nrow = sum(unlist(nList2)),ncol = 4)
  
  n2count <- 0
  for(i in 1:n2){
    ni <- nList2[[i]]
    phaseInt[(n2count + 1):(n2count + ni),1] <- as.numeric(rep(i,ni))
    phaseInt[(n2count + 1):(n2count + ni),2] <- as.numeric(tList2[[i]])
    phaseInt[(n2count + 1):(n2count + ni),3] <- as.numeric(YList2[[i]])
    phaseInt[(n2count + 1):(n2count + ni),4] <- rep("Internal",ni)
    n2count <- n2count + ni
  }
  
  phaseInt <- as.data.frame(phaseInt)
  colnames(phaseInt) <- c("psuedo_id","TimeW","Value","Phase")
  phaseInt$psuedo_id <- as.numeric(phaseInt$psuedo_id)
  phaseInt$TimeW <- as.numeric(phaseInt$TimeW)
  phaseInt$Value <- as.numeric(phaseInt$Value)
  
  # conduct z-transform
  mVal <- mean(phaseInt$Value[which(phaseInt$TimeW <= 10)])
  sdVal <- sd(phaseInt$Value[which(phaseInt$TimeW <= 10)])
  
  # transform to the original scale
  # data selection
  beta1List <- c()
  beta2List <- c()
  beta3List <- c()
  beta4List <- c()
  beta5List <- c()
  pSampList <- c()
  pMinusList <- c()
  ZCount <- as.numeric(n)
  for(j in (5e2+1):1e3){
    beta1List[j-5e2] <- outSelection[[i_seed]]$betaStarList[[j]][1] * sdVal + mVal
    beta2List[j-5e2] <- outSelection[[i_seed]]$betaStarList[[j]][2] * sdVal
    beta3List[j-5e2] <- outSelection[[i_seed]]$betaStarList[[j]][3] * sdVal + mVal
    beta4List[j-5e2] <- outSelection[[i_seed]]$betaStarList[[j]][4] * sdVal
    beta5List[j-5e2] <- outSelection[[i_seed]]$betaStarList[[j]][5] * sdVal + mVal
    pSampList[j-5e2] <- mean(outSelection[[i_seed]]$Z1L[[j]])
    pMinusList[j-5e2] <- (sum(outSelection[[i_seed]]$Z1L[[j]][1 : ZCount]) >=
                                sum(outSelection[[i_seed]]$Z1L[[j]][(ZCount+1): (2 * ZCount)]))
  }
  
  # direct combination
  beta1CompList <- c()
  beta2CompList <- c()
  beta3CompList <- c()
  beta4CompList <- c()
  beta5CompList <- c()
  for(j in (1e3+1):2e3){
    beta1CompList[j-1e3] <- outComp[[i_seed]]$betaStarList[[j]][1] * sdVal + mVal
    beta2CompList[j-1e3] <- outComp[[i_seed]]$betaStarList[[j]][2] * sdVal
    beta3CompList[j-1e3] <- outComp[[i_seed]]$betaStarList[[j]][3] * sdVal + mVal
    beta4CompList[j-1e3] <- outComp[[i_seed]]$betaStarList[[j]][4] * sdVal
    beta5CompList[j-1e3] <- outComp[[i_seed]]$betaStarList[[j]][5] * sdVal + mVal
  }
  # l1Start
  absLoss12List[i_seed] <- median(abs((beta1List - 20)/20) + abs((beta2List - 1)/1))
  # l1Plateau
  absLoss5List[i_seed] <- median(abs((beta5List - 8)/8))
  # p_Ext
  pList[i_seed] <- median(pSampList)
  # p_ifPrefer
  pDiffList[i_seed] <- median(pMinusList)
  # l1Start
  absLoss12CompList[i_seed] <- median(abs((beta1CompList - 20)/20) + abs((beta2CompList - 1)/1))
  # l1Plateau
  absLoss5CompList[i_seed] <- median(abs((beta5CompList - 8)/8))
  # p_ifSmall
  ifSmall[i_seed] <- absLoss12List[i_seed] <= absLoss12CompList[i_seed]
  
}
print("absLoss12")
print(median(absLoss12List))
print(quantile(absLoss12List,probs = 0.75) - quantile(absLoss12List,probs = 0.25))
print("absLoss5")
print(median(absLoss5List))
print(quantile(absLoss5List,probs = 0.75) - quantile(absLoss5List,probs = 0.25))

print("absLoss12DirectComb")
print(median(absLoss12CompList))
print(quantile(absLoss12CompList,probs = 0.75) - quantile(absLoss12CompList,probs = 0.25))
print("absLoss5DirectComb")
print(median(absLoss5CompList))
print(quantile(absLoss5CompList,probs = 0.75) - quantile(absLoss5CompList,probs = 0.25))

print("p_Ext")
print(median(pList))
print(quantile(pList,probs = 0.75) - quantile(pList,probs = 0.25))
print("p_ifPrefer")
print(mean(pDiffList))
print("p_ifSmall")
print(mean(ifSmall))
```  

DGP4, $K = 20, \rho = 0.5$,

```{r}
path <- "your_path/DGP4"

fileName <- paste(path,"hemophiliaWrongPlateauRho05n10",sep = "")
load(fileName)

outSelection <- outList

fileName <- paste(path,"hemophiliaWrongPlateauCompRho05n10",sep = "")
load(fileName)

ZCount <- 10
      
outComp <- outList

absLoss12List <- c()
absLoss5List <- c()
pList <- c()
pDiffList <- c()

absLoss12CompList <- c()
absLoss5CompList <- c()

ifSmall <- c()

for(i_seed in 1:1e2){
  set.seed(i_seed)
  
  # D1
  #####
  Ts1 <- 120
  alpha1 <- matrix(60,nrow = 1,ncol = 1)
  n1 <- 10
  theta1 <- c(20,1,10,-0.1,8)
  
  # wrong D
  Tsw <- 120
  alphaw <- matrix(60,nrow = 1,ncol = 1)
  nw <- 10
  thetaw <- c(10,4,20,-1,12)
  
  tList1 <- list()
  nList1 <- list()
  XList1 <- list()
  YList1 <- list()
  
  for(i in 1:n1){
    ni <- rpois(1,lambda = 20)
    tList1[[i]] <- matrix(sort(runif(ni,min = 0,max = Ts1)),ncol = 1)
    nList1[[i]] <- ni
  }
  
  XList1 <- getXList(tList1,alpha1[1,1],Ts1)
  thetaMat1 <- matrix(0,nrow = n1 + nw,ncol = 5)
  SigMat1 <- diag(c(abs(c(25,0.1,9,0.1,4))))
  
  for(i in 1:n1){
    ni <- length(tList1[[i]])
    thetai <- tmvtnorm::rtmvnorm(1,mean = theta1,sigma = SigMat1)
    thetaMat1[i,] <- thetai
    epsMat <- arMat(rho = 0.5,tListi = tList1[[i]])
    eps <- mvtnorm::rmvnorm(1,mean = rep(0,ni),sigma = 4*epsMat)
    
    YList1[[i]] <- matrix(c(XList1[[i]]%*%matrix(thetai,ncol = 1)) + c(eps), ncol = 1) 
    
  }
  
  for(i in (n1+1):(n1 + nw)){
    ni <- rpois(1,lambda = 20)
    tList1[[i]] <- matrix(sort(runif(ni,min = 0,max = Tsw)),ncol = 1)
    nList1[[i]] <- ni
  }
  
  XList1 <- getXList(tList1,alphaw[1,1],Tsw)
  SigMatw <- diag(c(abs(c(25,0.1,9,0.1,4))))
  
  for(i in (n1+1):(n1 + nw)){
    ni <- length(tList1[[i]])
    thetai <- tmvtnorm::rtmvnorm(1,mean = thetaw,sigma = SigMatw)
    thetaMat1[i,] <- thetai
    
    epsMat <- arMat(rho = 0.5,tListi = tList1[[i]])
    eps <- mvtnorm::rmvnorm(1,mean = rep(0,ni),sigma = 4*epsMat)
    
    YList1[[i]] <- matrix(c(XList1[[i]]%*%matrix(thetai,ncol = 1)) + c(eps), ncol = 1) 
    
  }
  
  phaseExt <- matrix(0,nrow = sum(unlist(nList1)),ncol = 4)
  
  n1count <- 0
  for(i in 1:(n1 + nw)){
    ni <- nList1[[i]]
    phaseExt[(n1count + 1):(n1count + ni),1] <- rep(i,ni)
    phaseExt[(n1count + 1):(n1count + ni),2] <- tList1[[i]]
    phaseExt[(n1count + 1):(n1count + ni),3] <- YList1[[i]]
    phaseExt[(n1count + 1):(n1count + ni),4] <- rep("External",ni)
    n1count <- n1count + ni
  }
  
  phaseExt <- as.data.frame(phaseExt)
  colnames(phaseExt) <- c("psuedo_id","TimeW","Value","Phase")
  phaseExt$psuedo_id <- as.numeric(phaseExt$psuedo_id)
  phaseExt$TimeW <- as.numeric(phaseExt$TimeW)
  phaseExt$Value <- as.numeric(phaseExt$Value)
  
  #####
  # D2
  Ts2 <- 120
  alpha2 <- matrix(60,nrow = 1,ncol = 1)
  n2 <- 40
  theta2 <- c(20,1,10,-0.1,8)
  
  tList2 <- list()
  nList2 <- list()
  XList2 <- list()
  YList2 <- list()
  
  for(i in 1:n2){
    ni <- rpois(1,lambda = 20)
    # truncated before 40
    tList2[[i]] <- matrix(sort(runif(ni,min = 0,max = 60)),ncol = 1)
    nList2[[i]] <- ni
  }
  
  XList2 <- getXList(tList2,alpha2[1,1],Ts2)
  thetaMat2 <- matrix(0,nrow = n2,ncol = 5)
  SigMat2 <- diag(c(abs(c(25,0.1,9,0.1,4))))
  
  for(i in 1:n2){
    ni <- length(tList2[[i]])
    thetai <- tmvtnorm::rtmvnorm(1,mean = theta2,sigma = SigMat2)
    thetaMat2[i,] <- thetai
    
    epsMat <- arMat(rho = 0.5,tListi = tList2[[i]])
    eps <- mvtnorm::rmvnorm(1,mean = rep(0,ni),sigma = 4*epsMat)
    
    YList2[[i]] <- matrix(c(XList2[[i]]%*%matrix(thetai,ncol = 1)) + c(eps), ncol = 1) 
    
  }
  
  phaseInt <- matrix(0,nrow = sum(unlist(nList2)),ncol = 4)
  
  n2count <- 0
  for(i in 1:n2){
    ni <- nList2[[i]]
    phaseInt[(n2count + 1):(n2count + ni),1] <- as.numeric(rep(i,ni))
    phaseInt[(n2count + 1):(n2count + ni),2] <- as.numeric(tList2[[i]])
    phaseInt[(n2count + 1):(n2count + ni),3] <- as.numeric(YList2[[i]])
    phaseInt[(n2count + 1):(n2count + ni),4] <- rep("Internal",ni)
    n2count <- n2count + ni
  }
  
  phaseInt <- as.data.frame(phaseInt)
  colnames(phaseInt) <- c("psuedo_id","TimeW","Value","Phase")
  phaseInt$psuedo_id <- as.numeric(phaseInt$psuedo_id)
  phaseInt$TimeW <- as.numeric(phaseInt$TimeW)
  phaseInt$Value <- as.numeric(phaseInt$Value)
  
  # conduct z-transform
  mVal <- mean(phaseInt$Value[which(phaseInt$TimeW <= 10)])
  sdVal <- sd(phaseInt$Value[which(phaseInt$TimeW <= 10)])
  
  # transform to the original scale
  # data selection
  beta1List <- c()
  beta2List <- c()
  beta3List <- c()
  beta4List <- c()
  beta5List <- c()
  pSampList <- c()
  pMinusList <- c()
  ZCount <- as.numeric(n)
  for(j in (5e2+1):1e3){
    beta1List[j-5e2] <- outSelection[[i_seed]]$betaStarList[[j]][1] * sdVal + mVal
    beta2List[j-5e2] <- outSelection[[i_seed]]$betaStarList[[j]][2] * sdVal
    beta3List[j-5e2] <- outSelection[[i_seed]]$betaStarList[[j]][3] * sdVal + mVal
    beta4List[j-5e2] <- outSelection[[i_seed]]$betaStarList[[j]][4] * sdVal
    beta5List[j-5e2] <- outSelection[[i_seed]]$betaStarList[[j]][5] * sdVal + mVal
    pSampList[j-5e2] <- mean(outSelection[[i_seed]]$Z1L[[j]])
    pMinusList[j-5e2] <- (sum(outSelection[[i_seed]]$Z1L[[j]][1 : ZCount]) >=
                                sum(outSelection[[i_seed]]$Z1L[[j]][(ZCount+1): (2 * ZCount)]))
  }
  
  # direct combination
  beta1CompList <- c()
  beta2CompList <- c()
  beta3CompList <- c()
  beta4CompList <- c()
  beta5CompList <- c()
  for(j in (1e3+1):2e3){
    beta1CompList[j-1e3] <- outComp[[i_seed]]$betaStarList[[j]][1] * sdVal + mVal
    beta2CompList[j-1e3] <- outComp[[i_seed]]$betaStarList[[j]][2] * sdVal
    beta3CompList[j-1e3] <- outComp[[i_seed]]$betaStarList[[j]][3] * sdVal + mVal
    beta4CompList[j-1e3] <- outComp[[i_seed]]$betaStarList[[j]][4] * sdVal
    beta5CompList[j-1e3] <- outComp[[i_seed]]$betaStarList[[j]][5] * sdVal + mVal
  }
  # l1Start
  absLoss12List[i_seed] <- median(abs((beta1List - 20)/20) + abs((beta2List - 1)/1))
  # l1Plateau
  absLoss5List[i_seed] <- median(abs((beta5List - 8)/8))
  # p_Ext
  pList[i_seed] <- median(pSampList)
  # p_ifPrefer
  pDiffList[i_seed] <- median(pMinusList)
  # l1Start
  absLoss12CompList[i_seed] <- median(abs((beta1CompList - 20)/20) + abs((beta2CompList - 1)/1))
  # l1Plateau
  absLoss5CompList[i_seed] <- median(abs((beta5CompList - 8)/8))
  # p_ifSmall
  ifSmall[i_seed] <- absLoss12List[i_seed] <= absLoss12CompList[i_seed]
  
}
print("absLoss12")
print(median(absLoss12List))
print(quantile(absLoss12List,probs = 0.75) - quantile(absLoss12List,probs = 0.25))
print("absLoss5")
print(median(absLoss5List))
print(quantile(absLoss5List,probs = 0.75) - quantile(absLoss5List,probs = 0.25))

print("absLoss12DirectComb")
print(median(absLoss12CompList))
print(quantile(absLoss12CompList,probs = 0.75) - quantile(absLoss12CompList,probs = 0.25))
print("absLoss5DirectComb")
print(median(absLoss5CompList))
print(quantile(absLoss5CompList,probs = 0.75) - quantile(absLoss5CompList,probs = 0.25))

print("p_Ext")
print(median(pList))
print(quantile(pList,probs = 0.75) - quantile(pList,probs = 0.25))
print("p_ifPrefer")
print(mean(pDiffList))
print("p_ifSmall")
print(mean(ifSmall))
```  

# Submit tasks with slurm

In this section, we demonstrate how to submit tasks with slurm. We need to first install the package that includes the cpp file (hemophiliaTruncAR1Final.cpp) using the following command in the sever's console after uploading hemophiliaAR1Hetero_1.0.tar.gz to your server,

R CMD INSTALL hemophiliaAR1Hetero_1.0.tar.gz

To submit tasks with slurm, for example, we need to upload folder DGP1 to the server and use the following command after directing to DGP1,

sbatch hemophiliaAR1Correct.sh

This command would submit a job array that runs the 100 simulations (seed 1 to 100).

Note that to run the code, we need to use R version 4.0.4.