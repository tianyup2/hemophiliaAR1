#include <RcppArmadillo.h>
#include <RcppDist.h>
#include <truncnorm.h>
#include <RcppArmadilloExtensions/sample.h>
// [[Rcpp::depends(RcppArmadillo)]]

using namespace Rcpp;

// [[Rcpp::export]]
double h00(double t){
  return(2 * std::pow(t,3) - 3 * std::pow(t,2) + 1);
}

// [[Rcpp::export]]
double h10(double t){
  return(std::pow(t,3) - 2 * std::pow(t,2) + t);
}

// [[Rcpp::export]]
double h01(double t){
  return(-2 * std::pow(t,3) + 3 * std::pow(t,2));
}

// [[Rcpp::export]]
double h11(double t){
  return(std::pow(t,3) - std::pow(t,2));
}

// [[Rcpp::export]]
arma::mat tmvnrnd(arma::mat Mu, arma::mat Sigma, int nTotal){
  // take a 5 X 1 Mu and 5 X 5 Sigma
  // if i exceeds nTotal, return a sample following mvnrnd(Mu, Sigma)
  int i;
  arma::mat out, outTemp, SigTemp;
  SigTemp = (Sigma + Sigma.t())/2;
  for(i = 0; i < nTotal; i++){
    outTemp = arma::mvnrnd(Mu,SigTemp,1);
    if(outTemp(2,0) >= outTemp(4,0) && outTemp(1,0)  >= 0 &&  outTemp(3,0) <= 0){
      break;
    }
  }
  
  if(outTemp(3,0) > 0){
    outTemp(3,0) = -1e-4;
  }
  out = outTemp;
  return(out);
}

// [[Rcpp::export]]
arma::mat arMat(double rho, arma::mat tListi){
  // return a ti by ti matrix, where ti is the length of tListi
  // assume tListi is sorted in an ascending order
  int i, j, ni = tListi.n_rows;
  arma::mat armat(ni,ni);
  for(i = 0; i < ni; i++){
    for(j = 0; j < ni; j++){
      armat(i,j) = std::pow(rho,std::abs(tListi(i,0)-tListi(j,0)));
    }
  }
  return(armat);
}

// [[Rcpp::export]]
arma::field<arma::mat> getXList(arma::field<arma::mat> tList, double alpha, double Ts){
  // Each element of tList is an ni X 1 matrix
  arma::mat tListi;
  arma::mat XListi;
  int i, j, nRowtListi, n = tList.n_elem;
  arma::field<arma::mat> XList(n);
  for(i = 0; i < n; i++){
    tListi = tList(i);
    nRowtListi = tListi.n_rows;
    XListi.zeros(nRowtListi,5);
    for(j = 0; j < nRowtListi; j++){
      if(tListi(j,0) <= alpha){
        XListi(j,0) = h00(tListi(j,0)/alpha);
        XListi(j,1) = h10(tListi(j,0)/alpha) * alpha;
        XListi(j,2) = h01(tListi(j,0)/alpha);
        XListi(j,3) = h11(tListi(j,0)/alpha) * alpha;
      }else{
        XListi(j,2) = h00((tListi(j,0)-alpha)/(Ts-alpha));
        XListi(j,3) = h10((tListi(j,0)-alpha)/(Ts-alpha)) * (Ts-alpha);
        XListi(j,4) = h01((tListi(j,0)-alpha)/(Ts-alpha));
      }
    }
    XList(i) = XListi;
  }
  return(XList);
}

// [[Rcpp::export]]
void getSampMixEffect(arma::field<arma::mat> YList,
                      arma::field<arma::mat> XList,
                      arma::mat beta0, double nu0, arma::mat Psi0,
                      double a0, double b0, 
                      arma::field<arma::mat> SigRhoiList,
                      arma::mat &betaStar, arma::mat &SigmaStar, 
                      arma::mat &sig20){
  // & is needed for passing the references of the parameters
  // Each element of YList should be an ni X 1 matrix
  // Each element of XList is generated by getXList
  // assume coefs are arranged into (mu_s0, m_s0, mu_s1, m_s1, mu_s2)
  // note m_s0 >= 0 and m_s1 <= 0
  // clarifications:
  // betaList is a 3D tensor, each slice, i.e., betaList.slice(i), should be a D X 1 vector
  // betaStar is a D X 1 vectors
  // SigmaStar is a D X D matrix
  // sig2 is a 1 X 1 matrix
  // rho is a 1 X 1 matrix
  // SigRhoiList is a n X 1 list, each elem is a ti X ti AR matrix
  // output:
  // 1. individual wise regression coefs, 2. population wise regression coefs mean
  // 3. population wise regression coefs cov, 4. regression std dev
  int i, n = YList.n_elem;
  // individual coefs
  arma::mat SigmaStarSol = SigmaStar.i();
  arma::mat matTemp, Xi, Yi;
  arma::field<arma::mat> MuiL(n), SigmaiL(n);
  arma::cube betaList(5,1,n);
  // overall coefs
  double nun;
  arma::mat Psin = Psi0.i() + beta0 * beta0.t(), SigmanStar, betanStar = beta0;
  arma::mat betaListi;
  arma::mat Sigma0Sub;
  NumericVector sampTemp;
  arma::mat wishSamp;
  double an0 = a0, bn0 = b0;
  arma::mat resid;
  arma::mat SigRhoi;
  // Step 1, get individual wise parameters
  
  for(i = 0; i < n; i++){
    Xi = XList(i);
    Yi = YList(i);
    SigRhoi = SigRhoiList(i);
    
    matTemp = SigmaStarSol + Xi.t() * SigRhoi.i() * Xi / sig20(0,0);
    SigmaiL(i) = matTemp.i();
    MuiL(i) = SigmaiL(i) * (SigmaStarSol * betaStar + Xi.t() *SigRhoi.i() * Yi / sig20(0,0));
    SigmaiL(i) = (SigmaiL(i) + SigmaiL(i).t())/2;
    
    betaListi = arma::mvnrnd(MuiL(i),SigmaiL(i),1);
    betaList.slice(i) = betaListi;
    
    // accumulation
    betanStar = betanStar + betaListi;
    Psin = Psin + betaListi * betaListi.t();
  }
  
  betanStar = betanStar/(n + 1);
  
  // Step 2, update overall coefs (truncated multi-normal)
  SigmanStar = (n + 1) * SigmaStarSol;
  SigmanStar = SigmanStar.i();
  
  nun = nu0 + n;
  Psin = Psin - betanStar * betanStar.t() * (n + 1);
  Psin = Psin.i();
  Psin = (Psin + Psin.t())/2;
  
  wishSamp = arma::wishrnd(Psin,nun);
  SigmaStar = wishSamp.i();
  
  betaStar = tmvnrnd(betanStar, SigmaStar/(n + 1), 2e3);
  
  // Step 3, update sig20
  for(i = 0; i < n; i++){
    Xi = XList(i);
    Yi = YList(i);
    SigRhoi = SigRhoiList(i);
    
    betaListi = betaList.slice(i);
    resid = Yi - Xi * betaListi;
    resid = resid.t() * SigRhoi.i() * resid;
    
    an0 = an0 + Yi.n_rows/2;
    bn0 = bn0 + 0.5 * resid(0,0);
  }
  
  sig20(0,0) = 1/arma::randg(arma::distr_param(an0,1/bn0));    
  
}

// [[Rcpp::export]]
void getSampMixEffectHetero(arma::field<arma::mat> YListS, arma::field<arma::mat> XListS,
                            arma::field<arma::mat> YListT, arma::field<arma::mat> XListT,
                            arma::mat beta0, double nu0, arma::mat Psi0,
                            double a0, double b0, 
                            arma::field<arma::mat> SigRhoiListS, arma::field<arma::mat> SigRhoiListT,
                            arma::mat &betaStar, arma::mat &SigmaStar, 
                            arma::mat &sig20S, arma::mat &sig20T){
  // & is needed for passing the references of the parameters
  // Each element of YList should be an ni X 1 matrix
  // Each element of XList is generated by getXList
  // assume coefs are arranged into (mu_s0, m_s0, mu_s1, m_s1, mu_s2)
  // note m_s0 >= 0 and m_s1 <= 0
  // clarifications:
  // betaList is a 3D tensor, each slice, i.e., betaList.slice(i), should be a D X 1 vector
  // betaStar is a D X 1 vectors
  // SigmaStar is a D X D matrix
  // sig20S is a 1 X 1 matrix
  // sig20T is a 1 X 1 matrix
  // sig20S/T refers to variance of the source/target data
  // rho is a 1 X 1 matrix
  // SigRhoiList is a n X 1 list, each elem is a ti X ti AR matrix
  // output:
  // 1. individual wise regression coefs, 2. population wise regression coefs mean
  // 3. population wise regression coefs cov, 4. regression std dev
  int i, nS = YListS.n_elem, nT = YListT.n_elem;
  // individual coefs
  arma::mat SigmaStarSol = SigmaStar.i();
  arma::mat matTemp, Xi, Yi;
  arma::field<arma::mat> MuiLS(nS), SigmaiLS(nS), MuiLT(nT), SigmaiLT(nT);
  arma::cube betaListS(5,1,nS), betaListT(5,1,nT);
  // overall coefs
  double nun;;
  arma::mat Psin = Psi0.i() + beta0 * beta0.t(), SigmanStar, betanStar = beta0;
  arma::mat betaListi;
  arma::mat Sigma0Sub;
  NumericVector sampTemp;
  arma::mat wishSamp;
  arma::mat PsiRes;
  double an0 = a0, bn0 = b0;
  arma::mat resid;
  arma::mat SigRhoi;
  // Step 1, get individual wise parameters
  // accumulate over the source data
  if(nS > 0){
    for(i = 0; i < nS; i++){
      Xi = XListS(i);
      Yi = YListS(i);
      SigRhoi = SigRhoiListS(i);
      
      matTemp = SigmaStarSol + Xi.t() * SigRhoi.i() * Xi / sig20S(0,0);
      SigmaiLS(i) = matTemp.i();
      MuiLS(i) = SigmaiLS(i) * (SigmaStarSol * betaStar + Xi.t() *SigRhoi.i() * Yi / sig20S(0,0));
      SigmaiLS(i) = (SigmaiLS(i) + SigmaiLS(i).t())/2;
      
      betaListi = arma::mvnrnd(MuiLS(i),SigmaiLS(i),1);
      betaListS.slice(i) = betaListi;
      
      // accumulation
      betanStar = betanStar + betaListi;
      Psin = Psin + betaListi * betaListi.t();
    }    
  }

  for(i = 0; i < nT; i++){
    Xi = XListT(i);
    Yi = YListT(i);
    SigRhoi = SigRhoiListT(i);
    
    matTemp = SigmaStarSol + Xi.t() * SigRhoi.i() * Xi / sig20T(0,0);
    SigmaiLT(i) = matTemp.i();
    MuiLT(i) = SigmaiLT(i) * (SigmaStarSol * betaStar + Xi.t() *SigRhoi.i() * Yi / sig20T(0,0));
    SigmaiLT(i) = (SigmaiLT(i) + SigmaiLT(i).t())/2;
      
    betaListi = arma::mvnrnd(MuiLT(i),SigmaiLT(i),1);
    betaListT.slice(i) = betaListi;
    
    // accumulation
    betanStar = betanStar + betaListi;
    Psin = Psin + betaListi * betaListi.t();
  }
  
  betanStar = betanStar/(nS + nT + 1);
  
  // Step 2, update overall coefs (truncated multi-normal)
  SigmanStar = (nS + nT + 1) * SigmaStarSol;
  SigmanStar = SigmanStar.i();
  
  nun = nu0 + nS + nT + 1;
  Psin = Psin - betanStar * betanStar.t() * (nS + nT + 1);
  Psin = Psin.i();
  PsiRes.eye(5,5);
  
  Psin = (Psin + Psin.t())/2 + 1e-8 * PsiRes;
  
  wishSamp = arma::wishrnd(Psin,nun);
  SigmaStar = wishSamp.i();
  
  betaStar = tmvnrnd(betanStar, SigmaStar/(nS + nT + 1), 1e3);
  
  // Step 3, update sig20S
  if(nS > 0){
    for(i = 0; i < nS; i++){
      Xi = XListS(i);
      Yi = YListS(i);
      SigRhoi = SigRhoiListS(i);
      
      betaListi = betaListS.slice(i);
      resid = Yi - Xi * betaListi;
      resid = resid.t() * SigRhoi.i() * resid;
      
      an0 = an0 + Yi.n_rows/2;
      bn0 = bn0 + 0.5 * resid(0,0);
    }
    
    sig20S(0,0) = 1/arma::randg(arma::distr_param(an0,1/bn0));     
  }
  
  // Step 4, update sig20T, reinit
  an0 = a0;
  bn0 = b0;
  
  for(i = 0; i < nT; i++){
    Xi = XListT(i);
    Yi = YListT(i);
    SigRhoi = SigRhoiListT(i);
    
    betaListi = betaListT.slice(i);
    resid = Yi - Xi * betaListi;
    resid = resid.t() * SigRhoi.i() * resid;
    
    an0 = an0 + Yi.n_rows/2;
    bn0 = bn0 + 0.5 * resid(0,0);
  }
  
  sig20T(0,0) = 1/arma::randg(arma::distr_param(an0,1/bn0)); 
  
}

// [[Rcpp::export]]
double getMLMixEffect(arma::field<arma::mat> YList,
                      arma::field<arma::mat> XList,
                      arma::field<arma::mat> SigRhoiList,
                      arma::mat betaStar, arma::mat SigmaStar, 
                      arma::mat sig20){
  // This function returns the marginal likelihood given population wise coefs and cov,
  // as well as the error term. Namely, the likelihood is calculated by marginalizing out
  // the individual-wise (mix) effect
  int i, ni, n = YList.n_elem;
  arma::mat SigmaStarSol = SigmaStar.i();
  arma::mat SigmaStarSoli, Xi, Yi;
  arma::mat SigRhoi;
  arma::mat Mui, matprod1, matprod2, matprod3;
  double logllk = 0;
  
  for(i = 0; i < n; i++){
    Xi = XList(i);
    Yi = YList(i);
    ni = Yi.n_rows;
    SigRhoi = SigRhoiList(i);
    
    SigmaStarSoli = Xi.t() * SigRhoi.i() * Xi/sig20(0,0) + SigmaStarSol;
    Mui = SigmaStarSoli.i() * (Xi.t() * SigRhoi.i() * Yi/sig20(0,0) + 
      SigmaStarSol * betaStar);
    
    matprod1 = Yi.t() * SigRhoi.i() * Yi/sig20(0,0);
    matprod2 = betaStar.t() * SigmaStarSol * betaStar;
    matprod3 = Mui.t() * SigmaStarSoli * Mui;
    
    logllk = logllk - 0.5 * ni * log(2*arma::datum::pi) - 0.5 * ni * log(sig20(0,0)) - 
      0.5 * std::real(arma::log_det(SigRhoi)) +
      0.5 * std::real(arma::log_det(SigmaStarSol)) -
      0.5 * std::real(arma::log_det(SigmaStarSoli)) -
      0.5 * matprod1(0,0) - 0.5 * matprod2(0,0) + 0.5 * matprod3(0,0);
  }
  return(logllk);
}

// [[Rcpp::export]]
void getAlphaMixEffectHetero(arma::field<arma::mat> YListS, arma::field<arma::mat> XListS,
                             arma::field<arma::mat> tListS, 
                             arma::field<arma::mat> YListT, arma::field<arma::mat> XListT,
                             arma::field<arma::mat> tListT, 
                             double Ts,
                             arma::mat &alpha, arma::field<arma::mat> SigRhoiListS, arma::field<arma::mat> SigRhoiListT,
                             arma::mat betaStar, arma::mat SigmaStar, 
                             arma::mat sig20S, arma::mat sig20T, double deltaAlpha){
  // update alpha, use &.
  // we need Ts to be greater equal than 500, or we can take 520
  double alphaNew, MLOld, MLNew;
  arma::field<arma::mat> XListNew;
  alphaNew = R::runif(alpha(0,0)-deltaAlpha,alpha(0,0)+deltaAlpha);
  if(alphaNew > Ts){
    alphaNew = Ts - 1e-2;
  }else if(alphaNew < 50){
    alphaNew = 50;
  }
  
  // Accumulate target data
  XListNew = getXList(tListT, alphaNew, Ts);
  
  // alpha is assumed to be norm(52 * 6, sd = 52)
  
  MLOld = getMLMixEffect(YListT,XListT,SigRhoiListT,betaStar,SigmaStar,sig20T) - 
    0.5 * log(2 * arma::datum::pi) - log(52.0) - 0.5 * std::pow((alpha(0,0) - 52 * 4)/52.0,2);
  
  
  MLNew = getMLMixEffect(YListT,XListNew,SigRhoiListT,betaStar,SigmaStar,sig20T) - 
    0.5 * log(2 * arma::datum::pi) - log(52.0) - 0.5 * std::pow((alphaNew - 52 * 4)/52.0,2);
  
  // Accumulate source data
  if(YListS.n_elem > 0){
    XListNew = getXList(tListS, alphaNew, Ts);
    
    // alpha is assumed to be norm(52 * 6, sd = 52)
    
    MLOld = MLOld + getMLMixEffect(YListS,XListS,SigRhoiListS,betaStar,SigmaStar,sig20S);
    
    
    MLNew = MLNew + getMLMixEffect(YListS,XListNew,SigRhoiListS,betaStar,SigmaStar,sig20S);    
  }
  
  if(log(R::runif(0,1)) <= (MLNew - MLOld)){
    alpha(0,0) = alphaNew;
  }
}

// [[Rcpp::export]]
void getAlphaMixEffect(arma::field<arma::mat> YList, arma::field<arma::mat> XList,
                       arma::field<arma::mat> tList, double Ts,
                       arma::mat &alpha, arma::field<arma::mat> SigRhoiList,
                       arma::mat betaStar, arma::mat SigmaStar, 
                       arma::mat sig20, double deltaAlpha){
  // update alpha, use &.
  // we need Ts to be greater equal than 500, or we can take 520
  double alphaNew, MLOld, MLNew;
  arma::field<arma::mat> XListNew;
  alphaNew = R::runif(alpha(0,0)-deltaAlpha,alpha(0,0)+deltaAlpha);
  if(alphaNew > Ts){
    alphaNew = Ts - 1e-2;
  }else if(alphaNew < 50){
    alphaNew = 50;
  }
  XListNew = getXList(tList, alphaNew, Ts);
  
  // alpha is assumed to be norm(52 * 6, sd = 52)
  
  MLOld = getMLMixEffect(YList,XList,SigRhoiList,betaStar,SigmaStar,sig20) - 
    0.5 * log(2 * arma::datum::pi) - log(52.0) - 0.5 * std::pow((alpha(0,0) - 52 * 4)/52.0,2);
  
  
  MLNew = getMLMixEffect(YList,XListNew,SigRhoiList,betaStar,SigmaStar,sig20) - 
    0.5 * log(2 * arma::datum::pi) - log(52.0) - 0.5 * std::pow((alphaNew - 52 * 4)/52.0,2);
  
  if(log(R::runif(0,1)) <= (MLNew - MLOld)){
    alpha(0,0) = alphaNew;
  }
}

// [[Rcpp::export]]
arma::field<arma::mat> getRhoMixEffect(arma::field<arma::mat> YList,
                                       arma::field<arma::mat> tList, double Ts,
                                       arma::mat &rho, arma::field<arma::mat> SigRhoiList,
                                       arma::mat alpha, arma::mat betaStar, arma::mat SigmaStar, 
                                       arma::mat sig20, double deltaRho){
  // update alpha, use &.
  double rhoNew, MLOld, MLNew;
  int i, n = YList.n_elem;
  arma::mat tListi;
  arma::field<arma::mat> XList, SigRhoiListNew(n);
  rhoNew = R::runif(rho(0,0)-deltaRho,rho(0,0)+deltaRho);
  if(rhoNew < 0){
    rhoNew = 1e-2;
  }else if(rhoNew >= 1){
    rhoNew = 1 - 1e-2;
  }else{
    // pass
  }
  
  for(i = 0; i < n; i ++){
    tListi = tList(i);
    SigRhoiListNew(i) = arMat(rhoNew,tListi);
  }
  
  XList = getXList(tList, alpha(0,0), Ts);
  
  MLOld = getMLMixEffect(YList,XList,SigRhoiList,betaStar,SigmaStar,sig20);
  MLNew = getMLMixEffect(YList,XList,SigRhoiListNew,betaStar,SigmaStar,sig20);
  
  if(log(R::runif(0,1)) <= (MLNew - MLOld)){
    rho(0,0) = rhoNew;
    return(SigRhoiListNew);
  }else{
    return(SigRhoiList);
  }
}

// [[Rcpp::export]]
double getMLCondParams(arma::field<arma::mat> YListS, arma::field<arma::mat> tListS,
                       arma::field<arma::mat> YListT, arma::field<arma::mat> tListT,
                       double Ts, int nburn, int niter, double deltaAlpha, double deltaRho,
                       arma::mat beta0, 
                       double nu0, arma::mat Psi0,
                       double a0, double b0,
                       arma::mat alpha, arma::mat rho,
                       arma::mat betaStar, arma::mat SigmaStar, 
                       arma::mat sig20){
  // mlCur: current marginal likelihood for the i-th iteration
  // mlCum: cumulative marginal likelihood so far
  // all the marginal likelihood values are at the logarithmic scale
  // YListS/YListT denotes the source/target (old/new) dataset.
  double mlCur, mlCum = -arma::datum::inf, mlMax = -arma::datum::inf;
  arma::field<arma::mat> XListS, XListT;
  arma::mat SigmaStarSol, SigmaStarSoli, Mui;
  arma::mat SigRhoi;
  arma::mat matprod1, matprod2, matprod3, Xi, Yi, tListi;
  int i, j, ni, n = YListT.n_elem, nS = YListS.n_elem;
  arma::field<arma::mat> SigRhoiList(nS);
  
  // get arMat from give rho
  for(i = 0; i < nS; i++){
    tListi = tListS(i);
    SigRhoiList(i) = arMat(rho(0,0), tListi);
  }
  
  for(i = 0; i < niter; i++){
    
    XListS = getXList(tListS,alpha(0,0),Ts);
    XListT = getXList(tListT,alpha(0,0),Ts);
    
    // update parameters
    getSampMixEffect(YListS, XListS,
                     beta0, nu0, Psi0,
                     a0, b0, SigRhoiList,
                     betaStar, SigmaStar, sig20);
    
    getAlphaMixEffect(YListS, XListS,
                      tListS, Ts,
                      alpha, SigRhoiList,
                      betaStar, SigmaStar, 
                      sig20, deltaAlpha);
    
    SigRhoiList = getRhoMixEffect(YListS, tListS, Ts,
                                  rho, SigRhoiList,
                                  alpha, betaStar, SigmaStar, 
                                  sig20, deltaRho);
    
    SigmaStarSol = SigmaStar.i();
    
    if(i >= nburn){
      mlCur = 0;
      for(j = 0; j < n; j++){
        Xi = XListT(j);
        Yi = YListT(j);
        tListi = tListT(j);
        
        ni = Yi.n_rows;
        SigRhoi = arMat(rho(0,0),tListi);
        
        SigmaStarSoli = Xi.t() * SigRhoi.i() * Xi/sig20(0,0) + SigmaStarSol;
        Mui = SigmaStarSoli.i() * (Xi.t() * SigRhoi.i() * Yi/sig20(0,0) + 
          SigmaStarSol * betaStar);
        
        matprod1 = Yi.t() * SigRhoi.i() * Yi/sig20(0,0);
        matprod2 = betaStar.t() * SigmaStarSol * betaStar;
        matprod3 = Mui.t() * SigmaStarSoli * Mui;
        
        mlCur = mlCur -
          (- 0.5 * ni * log(2*arma::datum::pi) - 0.5 * ni * log(sig20(0,0)) - 
          0.5 * std::real(arma::log_det(SigRhoi)) +
          0.5 * std::real(arma::log_det(SigmaStarSol)) -
          0.5 * std::real(arma::log_det(SigmaStarSoli)) -
          0.5 * matprod1(0,0) - 0.5 * matprod2(0,0) + 0.5 * matprod3(0,0));
      }
      
      if(mlCur > mlMax){
        mlMax = mlCur;
      }
      
      mlCum = log(exp(mlCum - mlMax) + exp(mlCur - mlMax)) + mlMax;
    }
  }
  
  mlCum = - (mlCum - log(niter - nburn));
  return(mlCum);
}

// [[Rcpp::export]]
double getMLCondParamsHetero(arma::field<arma::mat> YListS, arma::field<arma::mat> tListS,
                             arma::field<arma::mat> YListT, arma::field<arma::mat> tListT,
                             double Ts, int nburn, int niter, double deltaAlpha, double deltaRho,
                             arma::mat beta0, 
                             double nu0, arma::mat Psi0,
                             double a0, double b0,
                             arma::mat alpha, arma::mat rho,
                             arma::mat betaStar, arma::mat SigmaStar, 
                             arma::mat sig20S, arma::mat sig20T){
  // mlCur: current marginal likelihood for the i-th iteration
  // mlCum: cumulative marginal likelihood so far
  // all the marginal likelihood values are at the logarithmic scale
  // YListS/YListT denotes the source/target (old/new) dataset.
  double mlCur, mlCum = -arma::datum::inf, mlMax = -arma::datum::inf;
  arma::field<arma::mat> XListS, XListT;
  arma::mat SigmaStarSol, SigmaStarSoli, Mui;
  arma::mat SigRhoi;
  arma::mat matprod1, matprod2, matprod3, Xi, Yi, tListi;
  int i, j, ni, nT = YListT.n_elem, nS = YListS.n_elem;
  arma::field<arma::mat> SigRhoiListS(nS), SigRhoiListT(nT);
  
  // get arMat from the given rho
  if(nS > 0){
    for(i = 0; i < nS; i++){
      tListi = tListS(i);
      SigRhoiListS(i) = arMat(rho(0,0), tListi);
    }    
  }
  
  for(i = 0; i < nT; i++){
    tListi = tListT(i);
    SigRhoiListT(i) = arMat(rho(0,0), tListi);
  }
  
  for(i = 0; i < niter; i++){
    
    XListS = getXList(tListS,alpha(0,0),Ts);
    XListT = getXList(tListT,alpha(0,0),Ts);
    
    // update parameters
    getSampMixEffectHetero(YListS, XListS,
                           YListT, XListT,
                           beta0, nu0, Psi0,
                           a0, b0, 
                           SigRhoiListS, SigRhoiListT,
                           betaStar, SigmaStar, 
                           sig20S, sig20T);
    
    getAlphaMixEffectHetero(YListS, XListS, tListS, 
                            YListT, XListT, tListT, 
                            Ts,
                            alpha, SigRhoiListS, SigRhoiListT,
                            betaStar, SigmaStar, 
                            sig20S, sig20T, deltaAlpha);
    
    if(nS > 0){
      SigRhoiListS = getRhoMixEffect(YListS, tListS, Ts,
                                     rho, SigRhoiListS,
                                     alpha, betaStar, SigmaStar, 
                                     sig20S, deltaRho);      
    }
    
    SigRhoiListT = getRhoMixEffect(YListT, tListT, Ts,
                                   rho, SigRhoiListT,
                                   alpha, betaStar, SigmaStar, 
                                   sig20T, deltaRho);
    
    SigmaStarSol = SigmaStar.i();
    
    if(i >= nburn){
      mlCur = 0;
      for(j = 0; j < nT; j++){
        Xi = XListT(j);
        Yi = YListT(j);
        tListi = tListT(j);
        
        ni = Yi.n_rows;
        SigRhoi = arMat(rho(0,0),tListi);
        
        SigmaStarSoli = Xi.t() * SigRhoi.i() * Xi/sig20T(0,0) + SigmaStarSol;
        Mui = SigmaStarSoli.i() * (Xi.t() * SigRhoi.i() * Yi/sig20T(0,0) + 
          SigmaStarSol * betaStar);
        
        matprod1 = Yi.t() * SigRhoi.i() * Yi/sig20T(0,0);
        matprod2 = betaStar.t() * SigmaStarSol * betaStar;
        matprod3 = Mui.t() * SigmaStarSoli * Mui;
        
        mlCur = mlCur -
          (- 0.5 * ni * log(2*arma::datum::pi) - 0.5 * ni * log(sig20T(0,0)) - 
          0.5 * std::real(arma::log_det(SigRhoi)) +
          0.5 * std::real(arma::log_det(SigmaStarSol)) -
          0.5 * std::real(arma::log_det(SigmaStarSoli)) -
          0.5 * matprod1(0,0) - 0.5 * matprod2(0,0) + 0.5 * matprod3(0,0));
      }
      
      if(mlCur > mlMax){
        mlMax = mlCur;
      }
      
      mlCum = log(exp(mlCum - mlMax) + exp(mlCur - mlMax)) + mlMax;
    }
  }
  
  mlCum = - (mlCum - log(niter - nburn));
  return(mlCum);
}
